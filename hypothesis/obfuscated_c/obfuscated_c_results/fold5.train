I jmp_buf J ; 
I void P ; 
I char L ; 
I int Q ; 
I H C ; 
I long long V ; 
I H char O ; 
I H short Y ; 
I H long long Z ; 
           O S [ ] = "syntax_error!" 
      "M@K~|JOEF\\^~_NHI]" ; L * N , * K , * 
        B , * E , * T , * A , * x , D ; Q ( * k ) ( ) , v ; V z ( P ) , j , _ , * 
      o , b , f , u , s , c , a , t , e , d ; J l ; Q _k ( P ) { R * K ? * K ++ : 
    ~ - d ; } V r ( L a ) { R a && putchar ( a ) ; } L n ( ) { R * T = j = 
         k ( ) , ++ j ; } O G ( P ) { * o = d , longjmp ( l , b ) ; } Z g ( Y a ) { R a 
      >> s | ( a & ~ - e ) << s ; } C p ( L * T ) { W ( r ( * T ++ ) ) ; * -- T - c && r ( c ) ; } L m 
    ( P ) { W ( ! ( ( v = A [ * T ++ ] ) - f ) ) ; R v ; } P q ( L * * N ) { O * q ; b = ! b ; f = - ~ b ; 
   u = f | b ; s = b << u ; c = s | f ; a = s << f ; t = - ~ u ; e = a 
        << u ; D = v = u << t ; q = S + c - ~ t ; q [ ~ s ] = a ; 
       q -- [ f ] += a ; q -- [ c ] += a ; B = ( L * ) 
       N + ~ e * e ; x = B + e ; A = B + e / f ; 
     o = ( V * ) ( x + a ) ; A [ - 
     ~ s ] = f ; T = K = A - 
    a * f ; A [ * -- q ] = c + 
    c ; * q = ! c ; W 
   ( ++ j && * ++ q ) 
   A [ * q - a ] = j ; 
   W ( v < D + c ) 
   x [ v - D ] = 
   v , A [ v ++ 
   ] = j ; ++ j 
    , v = D = e / 
     t ; W ( ++ 
      v <= D + f * 
       u ) x [ v - D + ~ 
       - c ] = v | a , A [ 
  v ] = A [ v | a ] = j ; 
    W ( ( A [ v ] = A [ v | a 
      ] = j , ++ v < a * u + ~ t ) ) ; 
         for ( ; E = * ++ N ; T [ ~ d ] 
     = a ) W ( * T ++ = * E ++ ) ; k = 
       T 
      - K ? _k : 
   getchar ; } Z h 
        ( C a ) { R ( g ( a ) << s * 
       f ) + g ( a >> s * f ) ; } P _i ( L * T ) 
      { * o || p ( T ) ; } V _b ( V a ) { Z e = a 
     ; R A [ * T ++ ] != v + c ? G ( ) : ~ - v ? a << z ( ) : c - A 
    [ * T ++ ] + b ? -- T , a >> z ( ) : e >> z ( ) ; } 
   V _c ( L * l ) { T = B + a ; W ( j ) * T -- 
   = v + j % c , j /= c ; E = B + ( * B == 
   a + c + u ) ; W ( T < B + a ) * 
   E ++ = * ++ T ; T = E ; 
   l - B && ++ * -- E ; } 
    P M ( Z k ) { L * p , e 
     = a >> u ; m ( ) && G ( 
      ) ; p = T = B ; _ = j = k 
       ; v = u << t , * T = a ; j < d 
       && ( * T ++ += c + u , j = j == - j ? ++ p , -- j : - j ) ; ! j ? * T ++ = 
      v : _c ( p ) ; * T ++ = - ~ s ; * T ++ = v ; * T ++ = a * t - s ; p = T 
    ; E = T += s * f ; W ( k ) * T -- = x [ k & ~ - a / f ] , k >>= e ; W ( T 
   - e * f > p ) * T -- = v ; W ( T < E ) * p ++ = * ++ T ; * p = d ; } P U 
   ( L * E ) { V * N = o , f ; * E = f = d ; W ( ++ f < c * u - u ) * ++ N 
   && ( M ( * N ) , r ( f + a * u ) , r ( - ~ s ) , p ( B ) , * ( T = E ) = d ) 
   ; } V w ( P ) { L * S = N , * x = N ; E = T = B ; E += a 
   << f ; 
   W ( T 
   < E 
   && n ( ) ) * 
   T == a - ~ u 
   ? U ( T ) , T : * T == c ? E = S ? T = S : T : S ? T : * T == ( a | u ) ? S = T : * T == a * f - c / f ? E = T : ! x && A [ * T ] != f ? x = T ++ : 
   ++ T ; * T = d ; R j && ! x ? w ( ) : T - B ; } P _d ( V e ) { L T = c * f - f ; V o = j * e + v ; D = d ; A [ v ] == T ++ ? D 
   = u << t : e > c && A [ v ] == T ++ && ( v | a ) - a * - ~ f < ~ - s ? D = b + ( v & a ) + a * f - c : d ; D && ( j = o - D ) ; } V y ( P ) { 
   V a = z ( ) ; W ( m ( ) && v < c + f && ( v -= u << b ) >= d ) v ? v - b ? v - f ? v - u ? v -= t , a = _b ( a ) : ( a &= z ( ) ) : ( a %= z ( 
   ) ) : ( a /= z ( ) ) : ( a *= z ( ) ) ; R -- T , a ; } V _f ( P ) { V e = c ; j = d ; D = b ; * T == u << t && ( e -= f ) && ( * 
   ++ T | a ) >> f == a - f && ( e <<= b ) && T ++ ; W ( D && ( v = * T ++ ) ) _d ( e ) ; R -- T , j ; } V F ( P ) { V n = y ( ) ; 
   W ( m ( ) && v < u * f ) v < t ? n += ( v - f ) * y ( ) : v - b ^ t ? n ^= y ( ) : ( n |= y ( ) ) ; R -- T , n ; } V i ( Z n ) { R n >> 
   a / f ? 
   n >> a 
     ? h ( n ) << a | h ( n >> a 
       ) : h ( n ) : g ( n ) ; } Q main ( Q x 
      , L * * K ) { V * A ; q ( K ) ; W ( w ( ) ) * * 
    K - c * c - b || p ( B ) , _i ( ! setjmp ( l ) ? T = B 
  , M ( ( ( A = ( * o = m ( ) == c - ~ s && ( j = a | T [ - b ] ) && 
       s - m ( ) == ~ s ) ? & o [ j - a * u ] : ( T = B , & _ ) ) , * A = F ( ) ) 
      ) , B : ( L * ) S ) ; } V z ( P ) { V 
     s ; W ( m ( ) && v <= f * c 
     ) R v < t ? ( v - f ) * 
    z ( ) : ( v -= u << 
    f ) < f ? v ? -- v 
   ? G ( ) : i ( z ( 
   ) ) : ~ z ( ) : 
   ( v -= f ) < u 
   ? v ? s = F ( ) 
   , m ( ) == a >> 
    b ? s : G ( ) : 
    _ : ! ( v -= 
     t ) ? -- T , _f 
      ( ) : v - f ? o [ 
       ( T [ - b ] | a ) - 
       a * u ] : ! z ( ) ; 
  G ( ) ; } ( ze , si , of ) ( ( ( n , i , t ) [ ] ) { _ ( ) , __VA_ARGS__ } ) / ( ze , si , of ) ( ( n , i , t ) ) - __ ( ) ) 
 ( n , i , t ) ( * ___ ) ( ( n , i , t ) ) = ( tch , pu , ar ) ; ( ub , do , le ) _ < : : > _ _ < % 
         - 2 , 1 , - 1.3 , 1.3 
, _ ( ) , _ ( ) , _ ( ) , _ ( ) , _ ( ) , _ ( ) , __ ( ',' , ',' , ',' , ',' , ',' ) * _ _ ( ) , ( _ _ ( ) 
- __ ( '_' , '_' ) ) * _ _ ( ) , _ ( ) , _ ( ) , _ ( ) , __ ( '_' , '_' ) * __ ( '_' , '_' , '_' , '_' , '_' ) * 
__ ( '_' , '_' , '_' , '_' , '_' ) * __ ( '_' , '_' , '_' , '_' , '_' ) + __ ( '_' , '_' , '_' , '_' , '_' ) 
, __ ( '_' , '_' , '_' , '_' , '_' , '_' , '_' , '_' , ) , _ ( ) m ( i , a , u ) ( ( n , i , t ) _ ) < % _ ( f , i ) ( 
 _ _ ( = , = ) __ ( _ ) ) _ ( _ ( f , i ) ( _ [ _ _ ( ) ____ ( _ , _ ) ] > _ [ _ _ ( ) ] ) _ [ _ _ ( ) ____ ( _ , _ 
, _ , _ , _ , _ , _ ) ] _ _ __ ( _ ) ) _ ( f , i ) ( _ [ _ _ ( ) ____ ( _ , _ , _ ) ] > _ [ _ _ ( ) + __ ( ) ] || 
_ [ _ _ ( ) ____ ( _ , _ , _ , _ , _ , _ , _ ) ] _ ( = , = ) __ ( ) ) r ( e , t ) _ [ __ ( _ , _ , _ , _ , _ , _ ) ] _ _ _ 
[ __ ( _ , _ , _ , _ , _ , _ , _ ) ____ ( _ , _ , _ , _ , _ , _ ) ] / _ [ __ ( _ , _ , _ , _ , _ ) ____ ( _ , _ , _ , _ , _ , _ ) ] * ( _ [ 
  __ ( ) ] - _ [ _ ( ) ] ) + _ [ _ ( ) ] ; _ [ __ ( _ , _ , _ , _ , _ , _ , _ ) ] _ _ _ [ __ ( _ , _ , _ , _ , _ , _ , _ ) ____ 
( _ , _ , _ , _ , _ ) ] / _ [ _ _ ( ) ] * ( _ [ __ ( _ , _ , _ , ) ] - _ [ __ ( _ , _ , ) ] ) + _ [ __ ( _ , _ , ) ] ; _ [ __ ( _ , _ , _ , _ , _ 
, _ , _ , _ ) ] _ _ _ [ _ _ ( ) - __ ( ) ] _ _ _ [ __ ( _ , _ , _ , _ , _ ) + _ _ ( ) - __ ( ) ] _ _ _ ( ) ; 
_f : _ [ __ ( _ , _ , _ , _ ) ] _ _ _ [ __ ( _ , _ , _ , _ , _ , _ , _ , _ ) ] * _ [ __ ( _ , _ , _ , _ , _ , _ , _ , _ ) ] ; 
_ [ __ ( _ , _ , _ , _ , _ ) ] _ _ _ [ _ _ ( ) - __ ( ) ] * _ [ _ _ ( ) - __ ( ) ] ; _ [ __ ( _ , _ , _ , _ , _ , _ , _ , _ , _ 
) ] _ _ __ ( _ , _ ) * _ [ __ ( _ , _ , _ , _ , _ , _ , _ , _ ) ] * _ [ _ _ ( ) - __ ( ) ] + _ [ __ ( _ , _ , _ , _ , _ , _ , _ ) ] ; 
_ [ __ ( _ , _ , _ , _ , _ , _ , _ , _ ) ] _ _ _ [ __ ( _ , _ , _ , _ ) ] - _ [ __ ( _ , _ , _ , _ , _ ) ] + _ [ __ ( _ , _ , _ , _ , _ , 
_ ) ] ; _ ( _ [ _ _ ( ) ____ ( _ , _ , _ , _ , ) ] ++ ) _ ( f , i ) ( ( _ [ _ _ ( ) ____ ( _ , _ , _ , _ , ) ] < _ [ _ _ ( ) 
____ ( _ , _ , _ , _ , _ ) ] ) && ( _ [ __ ( _ , _ , _ , _ ) ] + _ [ __ ( _ , _ , _ , _ , _ ) ] < _ [ _ _ ( ) ____ ( _ , _ , _ , _ , _ , _ ) 
] ) ) _ ( to , go ) _f ; _ ( ar , ch ) ( m , i , au ) [ ] _ _ < % __ ( _ , _ , _ ) * _ _ ( ) ____ ( _ , _ ) , __ 
( _ , _ , _ , _ ) * _ _ ( ) ____ ( _ , _ , _ ) , __ ( _ , _ , _ , _ , _ , _ ) * _ _ ( ) ____ ( _ , _ , _ , _ ) , __ ( _ , _ , _ , _ ) 
* _ _ ( ) ____ ( _ , _ , _ , _ , _ ) , __ ( _ , _ , _ , _ ) * _ _ ( ) ____ ( _ , _ , _ , _ , _ , _ ) , __ ( _ , _ , _ , _ ) * _ _ 
( ) ____ ( _ , _ ) % > ; ___ ( ( m , i , au ) [ ( ( n , i , t ) ) _ [ _ _ ( ) ____ ( _ , _ , _ , _ ) ] % __ ( _ , _ , _ , _ , _ ) ] ) ; 
 _ ( _ [ __ ( _ , _ , _ , _ , _ , _ , _ ) + __ ( _ , _ , _ , _ , _ , _ ) ] ++ ) { m ( i , a , u ) ( _ ( ) ) ; _ ( _ [ _ _ ( ) 
____ ( _ , _ ) ] ++ ) _ ( _ [ _ _ ( ) ____ ( _ , _ , _ ) ] _ _ _ ( ) ) _ ( f , i ) ( _ [ __ ( _ , _ , _ , _ , _ , _ , _ ) + 
_ _ ( ) ] != __ ( _ ) ) ___ ( _ _ ( ) ) ; { m ( i , a , u ) ( __ ( ) ) ; r ( e , t ) % > char J [ 1 << 18 ] ; int G [ W * p ] , _ , k , I = W / 4 + 1 , w = p / 4 + 1 ; float C , B , e ; 
unsigned So long A , n , d , t , h , x , f , o , r , a , l , L , F , i , s , H = 1 << 18 , b = 250 , D [ 1 << 14 ] , z [ W * p ] , q 
= 0x820008202625a0 ; main ( ) { Display * j = XOpenDisplay ( 0 ) ; Window u = XCreateSimpleWindow 
( j , RootWindow ( j , 0 ) , 0 , 0 , W , p , 1 , 0 , 0 ) ; XImage * Y = XCreateImage ( j , DefaultVisual ( j , 0 ) , 24 
, 2 , 0 , ( char * ) G , W , p , 32 , 0 ) ; XEvent M ; for ( XMapWindow ( j , u ) ; XSelectInput ( j , u , 1 ) && a - 
65307 ; ) { if ( ! H ) { if ( XCheckWindowEvent ( j , u , 1 , & M ) ) { a = XLookupKeysym ( & M . xkey , 0 ) ; * ( 
a & 1 ? & C : & B ) -= ( .05 
- a / 2 % 2 * .1 ) * ! ( a - 
1 & 4092 ^ 3920 ) ; a + 
2 & 0xfe0 ^ 0xfc0 || ( 
s = a + 2 & 31 ) ; } else 
{ y ( k , p + ) { F = k % w * 4 | k / w ; float a [ 6 ] , S = ( F - p / 2. ) / p ; 
y ( _ , W + ) { i = _ % I * 4 | _ / I ; if ( F < p & i < W ) { o = 1 ; L = i + F * W ; if 
( l = i & 3 ) ; else { l = F & 3 ; o = W ; } h = z [ L - o * l ] ; f = z [ L + ( 4 - 
l ) * o ] ; t = F - p / 2 || i - W / 2 ; r = h ^ f ; if ( ! l | ! t | ( int ) r | ( ! 
( h - 3 & 3 ) && 258063 & r >> 38 ) ) { float V = ( i - W / 2. ) / p , U = O ( 
S , 1 , B ) , m = 32768 , Q = m ; a [ 4 ] = O ( - 1 , S , B ) ; a [ 3 ] = O ( U , V , C ) 
; a [ 5 ] = O ( - V , U , C ) ; P ( ( a + 3 ) , s * 42 ) ; t || ( A = d ) ; f = 0 ; y ( n 
, ) { float N = a [ n + 3 ] , E = 1024 / fabs ( N ) ; b = N < 0 ; float K = 
( ( ( q >> 20 * n ) ^ ~ - b ) + ! b & 1023 ) / 1024. ; y ( d , ) a [ d ] = a [ d + 3 ] 
* E ; a [ n ] = round ( a [ n ] ) ; P ( a , K ) ; i = q + d ; P ( a , 1 ) ; e = E * 
K ; for ( ; e < m ; i += d ) { l = X ( i ) ; t = r = l ^ ( l ^ l - ( 1 << 6 * n ) ) 
& 63 << 6 * n ; if ( b ) { r = l ; l = t ; } if ( J [ r ] ) l = r ; if ( t = J 
[ l ] ) { x = ( n - 1 ) ? ( i | i >> 40 ) & 1023 | i >> 8 & 4190208 | 4194304 
: i & 1023 | i >> 28 & 4190208 | ( b ^ l == r ) << 23 ; if ( h = D [ ( x >> 6 
& 0xf | x >> 14 & 0x3f0 ) + t * 768 ] ) { o = h ; f = n | l * 4 | x << 32 ; m 
= e ; } if ( t == 8 & e < Q ) Q = e ; } e += E ; } } b = ( 255 - ( ( f & 3 ) + 
2 ) % 3 * 51 ) * ( 1 - m / 32768 ) ; o = o * b >> 8 ; G [ L ] = o >> 32 << 8 | o & 
16711935 ; z [ L ] = 3 * ( Q <= m ) | f | b << 56 ; } else { d = l * ( f << 
8 >> 40 ) + ( 4 - l ) * ( h << 8 >> 40 ) >> 2 & 16774143 ; o = D [ ( d >> 6 & 
15 | d >> 14 & 1008 ) + J [ ( int ) h / 4 ] * 768 ] * ( b = h >> 56 ) >> 8 ; G [ 
L ] = o >> 32 << 8 | o & 16711935 ; z [ L ] = ( 
int ) h | d << 32 | b << 56 ; } } } } q += A ; 
XPutImage ( j , u + 0 , DefaultGC ( j , J [ X ( q 
) ] = 0 ) , Y , 0 , 0 , 0 , 0 , W , p ) ; } } else { L = 
-- H / 768 ; J [ H ] = R % 16 * ( R % 4 < abs ( ( H >> 
6 & 63 ) - 32 ) + abs ( ( H 
>> 12 & 63 ) - 32 ) - 3 ) ; 
i = H & 15 ; F = H % 768 
>> 4 ; if ( L < 16 ) { if 
( L - 1 | ! ( R % 3 ) ) b = R % 
96 ^ 255 ; l = i * i * 3 + i * 81 / 4 & 3 ; a = L > 3 ? L - 8 ? L - 5 ? 9858122 : 12365733 - 488848 * ( ( i + F / 4 * 4 ) % 8 && F % 
4 ) : R % 2 * 5298487 : 3352537 * L * L - 14202379 * L + 19205553 ; if ( L == 4 ) if ( F < l + 18 ) a = 6990400 ; else 
if ( l > F - 19 ) b *= 0.7 ; if ( L == 3 ) { if ( ( i - 1 & 15 ) < 14 & ( F - 1 & 15 ) < 14 & ! ( F & 16 ) ) { a = 12359778 ; _ = 7 
- i ; k = 7 - F % 16 ; _ ^= _ >> 31 ; k ^= k >> 31 ; b = 196 - R % 32 + ( k > _ ? k : _ ) % 3 * 42 ; } else { b *= 1 + R % 2 * ( .5 
- ( i & 1 ) ) ; } } D [ H ] = ( a & 16711935 | ( a & 65280 ) << 24 ) * ( b >> ( F >> 5 ) ) >> 8 & 0xff00ff00ff ; } } } } "|~0y'vWtA@:LcO9d}y.!uL!Gd+ml(<+Ds!J" 
            "e.6!r!%l6G!n~^<i=%pEwL%P!'<!FQt%u 5toG57j/3" 
         "!:E%;!ea!!!WqE0z!f/y}!%!!Qi6!uzt!n}?]!bl!ak!SetR<" 
       "Zj$x!~V!n&g8!cK! KrgR'8@c]!%-q9V.3fa[E8X%dY'w!#H <P~6" 
      "?guhljL!^P% ?" "8!@dP,!!o+fb" 
     "!pv!;!Hm%Ro4" "n:}nkD!Q!kN" 
     "e:| 'b5sc!e" 
     signal ( 13 , 1 ) , _ ( ) ; } f ( ) 
 char * O0 = O_o , OO , * Q1 , O5 [ 97 ] ; int * Q5 , _Q = 0 , Q0 = 0 , _O = 0 , _0 = 0 , O = 5 , QQ , O6 , Q6 , O3 
, Q4 , O4 = 41088 , O1 = sizeof ( O5 ) , O7 = 234 ; long long __ ; _ ( ) Q_ ( { ) int * Q3 , Q2 , O2 , C , 
QO , O9 = O , O8 = ! ! ! ! ! ! ! ! ! ! k ( RAFT ) ) ; long long Q8 ; char * Q9 = O_ ( 1 A ) O_ ( % dB ) O_ ( % dC 
) O_ ( 34 m ) "\xe2%c%c\r\n" O_ ( 0 m ) O_ ( % dA ) , * Q7 ; __ += ( __ * 92 + * O0 - 35 - __ ) * ( QO = Q_ ( ! 
! ) ( * O0 - 33 ) * ! O9 -- ) , O0 += O1 * QO , QO && _ ( ) , Q Q4 && ( O -- , _ ( ) , O0 += 194 , O ++ , Q4 -- , _ ( 
) ) ) , Q O = 0 , __ = 0 , _ ( ) , O = 3 , _ ( ) ) , Q __ && ( C = __ & 15 , _O += ( C < 2 ) * 12 + ! ( QO = C & 14 ^ 2 ) * ( 
4 - _O ) + ( C == 6 ) * ( 12 - 2 * _O ) + ( C > 6 ) * ( 9 - ( C - 7 ) % 3 ) , _Q += ! QO * ( _Q % QQ + ( C & 1 ) * O3 - _Q ) , 
_0 += ! _0 * ! QO + ( 1 - 2 * _0 ) * ! ( C ^ 4 ) , ( C == 5 ) && ( __ >>= 4 , Q8 = __ , Q7 = O0 , Q4 = __ & 15 , O = 1 , _ 
( ) | O ++ & _ ( ) , __ = Q8 , O0 = Q7 ) , Q3 = ( _Q += O8 * ( 9 * O4 * 
O1 > lrand48 ( ) ) + ( _O %= 8 , ( ( _O % 6 > 2 ) - ( _O % 
7 < 2 ) ) * QQ + ( ( _O + 7 ) % 8 < 3 ) - ( _O > 4 ) ) * ( C > 5 ) , 
Q2 = _Q / O3 ) * O6 + Q5 + ( O2 = _Q % QQ ) / 2 , * Q3 = * 
Q3 % O4 + O4 | ( 1 << Q_ ( "" "@CADBEHI" ) [ _Q % 2 + _Q 
% O3 / QQ * 2 ] - 64 ) * _0 , sprintf ( O5 , Q9 , Q2 + 1 , 
O2 / 2 , * Q3 >> 8 , 85 * 3 & * Q3 , Q2 + 1 ) && _0 && ( O = 8 , 
Q1 = O5 , _ ( ) ) , Q0 += ( O2 > Q0 ) * _0 * ( O2 - Q0 ) , __ 
+= ! ( C > 9 ) * ( 3 - __ + ( __ >> 4 ) ) - 3 , __ += ( C > 12 
) * ( ( __ << 4 ) + C - 3 - __ ) , usleep ( O4 * _0 / ( 3 * 
O8 + 1 ) ) , O = 3 , _ ( ) ) ) , ! O9 -- && read ( 
1 , & OO , 1 ) > 0 && ( O = ( QO = OO == 35 ) * 3 + 6 , _ ( ) 
, QO && ( OO = 10 , O = 6 , _ ( ) , 1 ) || ( O = 4 , _ ( ) ) , 0 ) || close ( dup2 ( 3 - dup2 ( 1 , dup ( 0 ) - 3 ) , 1 ) 
* 0 + 2 ) * 0 || Q write ( 1 , "> " , 2 ) , ioctl ( Q0 = 0 , TIOCGWINSZ , O5 ) ^ -- O & ( O3 = ( QQ = ( O6 = * 
( ( short * ) O5 + 1 ) ) * 2 ) * 4 ) , Q6 = - O1 , Q5 = calloc ( 3 * O6 , 8 ) , _ ( ) ) , Q ( O = 8 , QO = ! ( O2 = OO - 
10 ) | ! ( Q2 = OO - 32 ) * ( Q0 + 58 > QQ ) | ( Q0 + 12 > QQ ) ) && ( Q1 = O_ ( 3 B ) , _ ( ) , write ( 1 , "> " , 2 ) 
) , Q0 += ! QO * ! Q2 * 4 - QO * Q0 , O2 * Q2 && ( ! Q0 && ( memset ( Q5 , 0 , 3 * O3 ) , Q0 = 4 , Q1 = "\n\n\n" 
O_ ( 3 A ) , _ ( ) ) , O = 7 , _Q = 7 * QQ + Q0 + 2 , _O = _0 = 0 , OO += ( OO > 64 & OO < 91 ) * 32 , O0 = Q_ ( O_o ) + 
O7 , _ ( ) , ( * O0 - OO ) || ( O = 2 , O0 += 'a' , _ ( ) ) ) ) , Q * O0 - OO ) && ( * ( O0 += O1 ) - 33 ) && ( O = 0 , 
_ ( ) , O = 7 , O0 += O1 , _ ( ) ) , Q write ( 0 , Q1 , strlen ( Q1 ) ) ) , Q OO = Q_ ( O_o ) [ Q6 += O1 ] , ( Q6 
 % strlen ( O_o ) - O7 ) && ( O = 6 , _ ( ) , O = 9 , _ ( ) ) ) ; Q_ ( } ) 
main ( ) 
{ 
    puts ( "hello world!" ) ; 
} char * H = 
'c' width = '128' height = '128' style = 'width:256px;height:256px' 
> < script > x = y = - 1 ; v = window . c ; v . onmousemove = function ( e ) { x = e . p 
ageX - v . offsetLeft ; y = e . pageY - v . offsetTop } ; w = 
new WebSocket ( 'ws' + location . href . subs 
tr ( 4 ) ) ; w . binary "                          " Type = 
er 
e ) { c = v . getC "                                 " ontext ( '2d' ) 
; b = c . crea "              " teI "                 " mageData ( 12 
8 , 128 ) ; u = new Uint8Array ( d = e . data ) ; b . dat 
a . set ( u ) ; c . putImageData ( b , 0 , 0 ) ; u [ 0 ] = x / 2 ; 
u [ 1 ] = y / 2 ; w . send ( d . slice ( 0 , x < 0 ? 0 : 2 ) ) ; x = y = - 
1 } < / scr "   " ipt > 
, lu , lv , z ; void * f ; typedef unsigned long long 
l ; l * p , t [ 99 ] = { 0x67452301 , 0xEFCDAB89 , 0x98BADCFE 
, 308438 * 881 , 3285377520 } , i , j , k , n , m [ 204 ] ; 
void s ( ) { ; for ( k = 0 ; k ++ < 7 * 2 * 9 ; ) for ( i = 
0 ; ++ i < 127 ; ) e = d + i * 4 + 512 * k , 1 [ e ] += ( i - u ) * ( i 
- u ) + ( k - v ) * ( k - v ) < 20 ? * e += UV_DROP : 0 ; } l * q = m , g = 1LL << 32 ; 
l ( h ) ( l v , l ( a ) ) { return ( v << a ) | ( v % g >> ( 32 - a ) ) ; } int main 
( int c , char * * y ) { for ( e = d ; fgets ( b , m [ 97 ] = 480 , 
stdin ) && * b > 31 ; ) for ( i = j = 0 ; n = b [ i ] , i < 18 ? ( l ) 
ocket - key : 
"258EAFA5-" "E914-47DA-95CA-C5AB0DC85B" "11\x80" [ j - 24 ] ) 
<< ( 3 - j % 4 ) * 8 , ++ j < 61 : 1 ; ) i ++ ; for ( j = 3 ; -- j ; ) { for ( i = 4 ; ++ i < 74 
; ) i > 9 ? p = q + i - 2 , p [ 8 ] = h ( p [ 5 ] ^ * p ^ p [ - 6 ] ^ p [ - 8 ] 
, 1 ) : ( t [ i ] = t [ 9 - i ] ) ; for ( p = t + 7 , i = - 1 ; ++ i < 82 ; k 
= * p ++ , p [ 2 ] = h ( p [ 1 ] , 5 ) + p [ - 3 ] + n + ( i / + 20 % 2 ? * p ^ k ^ p [ - 
2 ] : ( * p & k ) | ( ( i < 20 ? ~ * p : * p | k ) & p [ - 2 ] ) ) + * q ++ , t [ + 
81 - i ] += ( i > 76 ) * ( * p = h ( * p , 30 * ( i < 80 ) 
) ) ) for ( ; n - k ; n = ( ( ( 1LL + ( 9 << i / 20 
) / 8 ) << 60 ) / k + k ) / 2 ) k = n ; } for ( i = 0 ; i < 57 ; 
i ++ ) i < 30 ? q [ i % 5 * 16 / 3 + i / 5 ] |= t [ i % 5 ] % g << 4 
>> ( 30 + i % 5 % 3 * 2 - i / 5 * 6 ) & 63 , 0 : ( n = * q ++ , b [ i - 30 ] = 
n < 62 ? n - 37 + "fl!" [ n / 26 ] : n * 4 - 205 ) ; for ( prin 
tf ( "HTTP/1.1 " "%d " 
on : % s % .27 s = "       ,101   +99*!  *m,!*m?H:" upgrade 
    Upgrade : webso "        " c "   " ket Sec - WebSocket - Acce 
pt : 
( ; * m ; c = 0 ) { for ( f = c < 2 ? 0 : fopen ( y [ 1 ] , "r" ) ; f && fscanf ( f , 
"%f,%f," , & u , & v ) > 0 ; ) s ( ) ; for ( ; j < SPEED * 4 ; j += 2 ) for ( i = 0 ; i < 
63504 ; e += 5 - j % 4 * 2 , z = TIMESTEP , * e = u + z * ( elta_u ) , e [ 1 ] = v + z * 
( elta_v ) , i += 4 ) for ( c = 0 ; c + 2 ; u = v , v = e [ 4 ] , lu = lv , lv = e [ - 508 ] + * e + 
e [ 8 ] + e [ 516 ] - v * 4 ) e = d + i + 512 + i / 504 * 8 + j % 4 - c -- ; for ( ; n = c % 4 , 65544 > 
c ; c ++ ) putchar ( c > 7 ? n > 2 || ( u = d [ c - n - 7 ] * 4 * ( n < 2 ? ! n ? RGB ) ) > 255 ? 255 : 
u < 0 ? 0 : u : c < 0 ? 124 - c * 3 : c == 5 ) ; for 
                 Alan Turing ( 1912 -- 1954 ) 
                char * s = 
                r 'Q]                    bh' l vQ ^ k g & c : % n | 
                N ] _o ptj9 lwg + ) d : b kg 
                c8 + ) d8 a % g + ) d8 _ g & ; bh 
                 g + u ) | d8ak = bl } ( Q ^ og ( O { MK6lM L ( rR pOpM866OsRlm N ( q 
                Q ] OsR _ ( lQoOa N9 m vOwwRor ~ } ( cN mkM : q ( Q ] % _ ( uU ] } _ { 8 b 
                % mRh ^ OaaD % / RI4 4 SNH % N4 RlMG / 2 MJ 24 O3NF ( tQ ? 1l N * N 
                + Q ] l mq9l8b ^ d , d xv SOPm R8 / lM ; b h & ^ / lM : k8b % & Q ^ - 
                h % c9 . / & N McPc % - d8 , c8 7 : b % ^ h % : 79 b ^ % 7 ON8r % Qr h Q 
                On % q N % O ~ M qN OMp RmPQ O % rQ rQ 
                MkQN 77 O j kd 7 O % d8 ( r RmM 
                : ( luN ] ( % mRMmO % lNRmO_loa8 % % O < b ( lQ h 'lQ    O^ln    ;b' % N & O ^ 6 sN 9 slltwzh & TmS 
                % R N oNS & pRM7O 
                                                mR8 } ( qQ O < b 
                                                '7M{N^kh        ' Q ] 
                    7 sN '    M8q;k' N_7vN 'nSM8    ' nR ; % M 
                    rQ ] 6 yN _ pQaM8m { px TmSt 6 O sM nRmUd s d77sNOsd 8 j 
                = nk ; | 8 k9 b1g ( Q ^ ) c : % ] k * Q ] g 9 % _h * ] + wnS _ + sTaa : & % { R 
                M < % { S { O_ & < kP8 ; '(    0d:`184>b)^15)OM        :23h)QN<' / M 
                    = b ( ^ 'h(Q]0h#    c_kah%0d9`b' / O ( Q ^ ( / SlM90 % M ( / RM ; & c & kckQ , - c 
                    . & kccMcOP & d 9 g ( = 6 : 69 j = b5g ( Q ^ 3 ( 2l NUO < b4 
                         7 O Q ] 0 ( 2 ( Q ] '2O    3' Q ] '_3a    N_1' 5 OMaMch & T mR RMPmSk U 7 
                        O 8 _a % % mS ] l_ % mR mS ] ] h 9 j_la _ 6 N ] g 9 j_laaaN : g 
                oM : 6 % N9b % g Q ^ 6 % N8b % g ^ l peoqemtemw Q7 O jQ O7 Q Ok 
                 7 OMQ ] k_ 7 O ckQaOrON epne luelue lpeoqempepneu e kf _a 
                                                lf ) ) * + , * * , * ) - ) / ) , 0 ) .0 ( 6 / 2 + 667 , ( & 
                . ] , * s , * c , d , t ; ; 
                ( * ++ s = Q [ d ++ ] ) ; ) ; for ( ; n > 1 && ( * ++ s = v [ 1 ] [ tgANs = H ; d = * c ++ 
                % 93 , d - 9 ; ) { in tYv = * s , g [ ] = { n + v , v - n , n * _ 
                , _ , , < v , n ? v / n : 0 , , , v >> n , v == n } ay 
                > t = 0 ; d < 4 && d >= 2 * ! ! n && ( c -= d / 3 * 2 _KK3 + * c ++ , t || v != 98 + d ) ; ) t += v ++ / 6 - 16 
                ? 0 : v / 2 % 3 - 1 cq * d - 1 4 ; t > 0 _t < 3 _z ( 105 < * c_X 
                [ d - 7 7 ] : d > 55 ? H_1 ) 21 ] = n , * _ _8 ( 9 ? * ++ s_4 & 12 > d_C f3 ] += 21 - d * 2 
                : d < 3 4 ? t : _Zadat57 < d ? p utchar ( n ) , v : 6 < a ] ( g + 99 ] = a { d2 xa6 , n 
                ; } re turnY_ . 
                p = q = 5000 + 0 + d ; * s ; s ++ ) if ( * s > 32 ) * p ++ = * s - 89 ? * s : 32 ; for ( p = 
                1152 + q ; ( b = * p ++ ) ; ) { for ( d [ 17 ] = 10 ; x = * p ++ , b < 
                92 && 34 < b -- ; * r ++ = x ) if ( x == 9 * 9 ) for ( ; * q ; x = 34 
                ) * r ++ = * q ++ ; for ( p -= b < 92 ; b -- > 4 * 23 ; r ++ ) * r = r [ 36 - x ] ; } puts ( d ) ; 
                return ( 0 ) ; } typedef struct e { 
 int op ; int x ; int y ; long a ; long b ; struct e * n ; 
} E ; 
typedef struct { 
 int y ; 
 E * e ; 
} X ; 
typedef struct { 
 long q ; 
 unsigned long long y ; 
} h ; 
typedef struct { 
 unsigned long z ; 
 unsigned long j ; 
 h b [ 1 ] ; 
} H ; 
int I ; 
int P ; 
H * A , * B ; 
FILE * f , * g ; 
X * Q , * q ; 
H * 
N ( H * O ) 
{ 
 unsigned long z ; 
 H * Y ; 
 z = O ? O -> z << 1 : 65536 ; 
 if ( ! ( Y = realloc ( O , sizeof ( * O ) + z * sizeof ( O -> b ) ) ) ) 
  err ( 2 , 0 ) ; 
 Y -> z = z ; 
 if ( ! O ) 
  Y -> j = 0 ; 
 return Y ; 
} 
H * 
F ( FILE * Q ) 
{ 
 unsigned long long h ; 
 H * y ; 
 long L , o , n ; 
 unsigned char buf [ 65536 ] , * b ; 
 y = N ( 0 ) ; 
 L = 1 ; 
 o = 0 ; 
 h = 14695981039346656037ULL ; 
 y -> b [ L ] . q = o ; 
 while ( 0 < ( n = fread ( buf , 1 , sizeof ( buf ) , Q ) ) ) { 
  b = buf ; 
  while ( 0 < n -- ) { 
   h ^= * b ; 
   h += ( h << 1 ) + ( h << 4 ) + ( h << 5 ) + ( h << 7 ) + ( h << 8 ) + ( h << 40 ) ; 
   o ++ ; 
   if ( * b ++ == '\n' ) { 
    y -> b [ L ++ ] . y = h ; 
    if ( y -> z <= L ) 
     y = N ( y ) ; 
    y -> b [ L ] . q = o ; 
    h = 14695981039346656037ULL ; 
   } 
  } 
 } 
 y -> j = L - 1 ; 
 rewind ( Q ) ; 
 return y ; 
} 
FILE * 
O ( char * u ) 
{ 
 int i ; 
 FILE * Q ; 
 if ( ! ( Q = fopen ( u , "r" ) ) && ! strcmp ( "-" , u ) ) { 
  if ( ( Q = tmpfile ( ) ) ) { 
   while ( ( i = getchar ( ) ) != EOF ) 
    fputc ( i , Q ) ; 
   rewind ( Q ) ; 
  } 
 } 
 if ( ! Q ) err ( 2 , "%s" , u ) ; 
 return Q ; 
} 
void 
W ( FILE * Q ) 
{ 
 int i ; 
 while ( ( i = fgetc ( Q ) ) != EOF ) { 
  putchar ( i ) ; 
  if ( i == '\n' ) 
   break ; 
 } 
} 
E * 
R ( E * K ) 
{ 
 E * a , * b ; 
 b = 0 ; 
 while ( K ) { 
  a = K -> n ; 
  K -> n = b ; 
  b = K ; 
  K = a ; 
 } 
 return b ; 
} 
void 
D ( E * K ) 
{ 
 E * a , * b ; 
 for ( K = R ( K ) ; K ; ) { 
  b = K ; 
  if ( K -> op ) { 
   do { 
    a = b ; 
    b = b -> n ; 
   } while ( b && b -> op && a -> y + 1 == b -> y ) ; 
   if ( K -> y < a -> y ) 
    printf ( "%da%d,%d\n" , K -> x , K -> y , a -> y ) ; 
   else 
    printf ( "%da%d\n" , K -> x , K -> y ) ; 
   fseek ( g , K -> b , SEEK_SET ) ; 
   for ( ; K != b ; K = K -> n ) { 
    printf ( "> " ) ; 
    W ( g ) ; 
   } 
  } else { 
   do { 
    a = b ; 
    b = b -> n ; 
   } while ( b && ! b -> op && a -> x + 1 == b -> x ) ; 
   if ( K -> x < a -> x ) 
    printf ( "%d,%dd%d\n" , K -> x , a -> x , K -> y ) ; 
   else 
    printf ( "%dd%d\n" , K -> x , K -> y ) ; 
   fseek ( f , K -> a , SEEK_SET ) ; 
   for ( ; K != b ; K = K -> n ) { 
    printf ( "< " ) ; 
    W ( f ) ; 
   } 
  } 
 } 
} 
void 
K ( int k ) 
{ 
 X h = Q [ k - 1 ] ; 
 X v = Q [ k + 1 ] ; 
 int x , y , op ; 
 E * p ; 
 if ( v . y < h . y + 1 ) { 
  op = 1 ; 
  y = h . y + 1 ; 
  p = h . e ; 
 } else { 
  op = 0 ; 
  y = v . y ; 
  p = v . e ; 
 } 
 x = y - k ; 
 if ( 0 < y || 0 < x ) { 
  E * e = malloc ( sizeof ( * e ) ) ; 
  e -> x = x ; 
  e -> y = y ; 
  e -> n = p ; 
  e -> op = op ^ I ; 
  e -> a = A -> b [ x ] . q ; 
  e -> b = B -> b [ y ] . q ; 
  if ( I ) { 
   long c = e -> a ; 
   e -> a = e -> b ; 
   e -> b = c ; 
   e -> x = y ; 
   e -> y = x ; 
  } 
  Q [ k ] . e = e ; 
 } 
 while ( x < A -> j && y < B -> j && A -> b [ x + 1 ] . y == B -> b [ y + 1 ] . y ) { 
  x ++ ; 
  y ++ ; 
 } 
 Q [ k ] . y = y ; 
} 
int 
T ( void ) 
{ 
 int k , p , d ; 
 if ( A -> j > B -> j ) { 
  void * t = A ; 
  A = B ; 
  B = t ; 
  I = 1 ; 
 } 
 d = B -> j - A -> j ; 
 if ( ! ( q = calloc ( A -> j + B -> j + 3 , sizeof ( * Q ) ) ) ) 
  err ( 2 , 0 ) ; 
 for ( k = 0 ; k < A -> j + B -> j + 3 ; k ++ ) 
  q [ k ] . y = - 1 ; 
 Q = q + A -> j + 1 ; 
 p = - 1 ; 
 do { 
  p ++ ; 
  for ( k = - p ; k < d ; k ++ ) { 
   K ( k ) ; 
  } 
  for ( k = d + p ; d <= k ; k -- ) { 
   K ( k ) ; 
  } 
 } while ( Q [ d ] . y != B -> j ) ; 
 if ( ! P ) 
  D ( Q [ d ] . e ) ; 
 free ( q ) ; 
 return d + 2 * p ; 
} 
int 
main ( int x , char * * y ) 
{ 
 int i ; 
 while ( ( i = getopt ( x , y , "d" ) ) != - 1 ) { 
  switch ( i ) { 
  case 'd' : 
   P = 1 ; 
   break ; 
  default : 
   optind = x ; 
   break ; 
  } 
 } 
 if ( x <= optind ) 
  errx ( 2 , "usage: %s [-d] file1 file2" , * y ) ; 
 f = O ( y [ optind ] ) ; 
 g = O ( y [ optind + 1 ] ) ; 
 if ( ! ( A = F ( f ) ) ) 
  err ( 2 , "%s" , y [ optind ] ) ; 
 if ( ! ( B = F ( g ) ) ) 
  err ( 2 , "%s" , y [ optind + 1 ] ) ; 
 i = T ( ) ; 
 if ( P ) printf ( "%d\n" , i ) ; 
 return 0 < i ; 
} e , h , f , g , i , j , k , l , m , n , o , p = 1 , * q , r , s = 5 , t , * u , x , y , z , A , B , C [ 
    333 * 7 ] , d = 333 ; D , E , F , G [ 2 ] , H , I , J , K , L , M , N = 1 , O , P , Q 
    , * R ; char * S , * * T ; ; 
    SDL_Surface * U , * V ; int * W ( X 
    ) { u = C + X * 7 ; b * u ) { u ++ ; x = u [ 0 ] ; y = u [ 1 
    ] ; H = u [ 2 ] ; z = ( H % 8 ) * 
    i ; A = ( H / 8 ) * i ; B = u [ 3 
    ] ; return u ; ; } return 
    0 ; } Y ( ) { O = 50 ; r = 0 ; t = 1 ; 
    } Z ( X , m , n , o ) { ; 
    return W ( X ) && B && ( m < x + i && n < 
    y + i && x < m + i && y < n + o ) ; } int * ba ( int * u ) { int X 
    , * bb = C ; a ( X , bb += 7 ) { b ! * bb ) { * bb = 1 ; R 
    = bb + 1 ; H = 6 ; while ( H -- ) * R ++ = * u ++ ; return bb ; } } return 0 ; } bc ( e ) { q [ 2 ] = e ; } bd 
    ( be , bf ) { int X , bg ; m += be ; n += bf ; I = e 
    - i ; m = m < 0 ? 0 : ( m > I ? I : m ) ; a ( X , 0 ) { b Z ( X 
    , m , n , o ) ) { bg = B & 1 ; b D && bg ) continue ; 
    m -= be ; n -= bf ; b B & 8 ) { u [ - 1 ] = 0 ; j = 1 ; bc ( 8 ) ; b B & 32 ) { n -= i ; 
    o = i * 2 ; } } b B & 16 && ! O ) { bc ( 32 + ( o > i ? 8 : 0 ) ) ; Y ( ) ; u [ - 1 ] = 0 ; } 
    b ( B & 128 && bf && s < 0 ) || ( B & 64 ) ) u [ - 1 ] = 0 ; b bg && ! O ) { b bf && s > 0 ) { 
 u [ 2 ] -- ; u [ 3 ] = bf = 0 ; s = - 6 ; } else { b j ) { bc ( 0 ) ; b o > i ) n += o = i ; D = 30 ; j = 0 ; 
 } else { bc ( 24 ) ; Y ( ) ; L = - 1 ; } } } b B & 4 ) { b bf && s < 0 ) { int I [ ] = { x , y - i , u [ 
 5 ] , u [ 4 ] , rand ( ) % 2 ? 1 : - 1 , 2 } ; u [ 2 ] ++ ; u [ 3 ] = 2 ; ba ( I ) ; } } b bf ) s = 1 ; break ; } 
 } } bh ( m , e , k , bi ) { H = k / 2 ; G [ bi ] = m > e - H ? k 
 - e : ( m > H ? H - m : 0 ) ; } bj ( X , be , bf ) { int bk ; 
 u [ 0 ] += be ; u [ 1 ] += bf ; W ( X ) ; E = x , F = y , I = 0 ; a 
 ( bk , 0 ) { b I = ( X != bk && Z ( bk , E , F , i ) && ( B & 6 ) 
 ) ) break ; } W ( X ) ; b I ) { b bf ) u [ 1 ] -= bf ; b 
 be ) { u [ 0 ] -= be ; u [ 4 ] *= - 1 * be ; } } W ( X ) ; } 
 bl ( ) { int bm = n , X ; SDL_FillRect ( U , 0 , M ) ; X = 4 ; while ( X 
 -- ) bd ( r , 0 ) ; X = 3 ; while ( X -- ) bd ( 0 , s ) ; b n > h && ! O ) Y ( ) ; 
 t = bm == n ; q [ 0 ] = m ; q [ 1 ] = n ; bh ( m , e , k , 0 ) ; bh ( n , h , l , 1 ) ; 
 a ( X , 0 ) { b W ( X ) ) { b B & 9 ) { bj ( X , u [ 4 ] , 0 ) ; bj ( X , 0 , 2 ) ; } b B & 1 ) { * u += u [ 4 ] ; b 
    ++ u [ 5 ] > 20 ) { u [ 4 ] *= - 1 ; u [ 5 ] = 0 ; } z += K 
    % 2 ? i : 0 ; } J = i ; b q == u ) { J = o ; b ! O ) { b 
    r ) z += i * ( K % 2 ) ; b ! t ) z = 48 ; z += p < 0 ? i * 4 : 0 
    ; } } b q != u || ! ( D && 0 == D % 3 ) ) { SDL_Rect 
    bn = { z , A , i , J } , bo = { G [ 0 ] + x , G [ 1 ] + y , i , 
    J } ; SDL_BlitSurface ( V , & bn , U , & bo ) ; } } 
    } b ( s += 2 ) > 2 ) s = 2 ; K ++ ; D -= D ? 1 : 0 ; b O ) 
    b ! -- O ) exit ( L ) ; } bp ( X ) { return strtol 
 ( T [ X ] , 0 , 0 ) ; } bq ( int H , int * br , int bs ) { int bt ; 
 bt = Q - P ; b bt > bs ) bt = bs ; SDL_MixAudio ( br , S + P , bt , 
 128 ) ; P += bt ; b P >= Q ) P = 0 ; } SDL_AudioSpec bu = { 8000 
 , 8 , 1 , 0 , 256 , 0 , 0 , bq } , bv ; main ( int bw , char * * bx ) { T 
  = bx ; int by , H = 255 , bz = H << 8 , bA = bz << 8 , bB = bA << 8 , 
  bC = bp ( 5 ) , bD = bp ( 6 ) ; SDL_Event bE ; o = i = bC / 8 ; k = bp ( 1 ) 
  , l = bp ( 2 ) , e = bp ( 3 ) , h = bp ( 4 ) ; M = bp ( 9 ) ; SDL_Init ( 
  0xffff ) ; b ! * ( char * ) & N ) { H = bB ; bz = bA ; bA = bz >> 8 ; 
  bB = 255 ; } U = SDL_SetVideoMode ( k , l , 0 , 0 ) ; V = SDL_CreateRGBSurface ( 1 << 15 , bC , bD , 32 , H , bz 
  , bA , bB ) ; fread ( V -> pixels , bC * bD * 4 , 1 , fopen ( T [ 7 ] , "r" ) ) ; SDL_OpenAudio ( & 
  bu , 0 ) ; SDL_LoadWAV ( T [ 8 ] , & bv , & S , & Q ) ; SDL_PauseAudio ( 0 ) ; 
  for ( ; ; ) { int u [ 6 ] , * I ; H = 0 ; while ( H < 6 ) scanf ( 
     "%d " , u + H ++ ) ; b u [ 5 ] < 0 ) break ; I = ba ( 
     u ) ; b ! u [ 3 ] ) { q = I + 1 ; m = u [ 0 ] ; n = u [ 1 ] ; 
    } } for ( ; ; ) { while ( 
  SDL_PollEvent ( & bE ) ) { by = bE . type == 3 ; b ! O && ( by || bE . 
  type == 2 ) ) { I = bE . key . keysym . sym ; b I == 276 ) r = 
  by ? 0 : ( p = - 1 ) ; b I == 275 ) r = by ? 0 : ( p = 1 ) ; b I == 32 ) by ? 
  0 : ( t ? ( s = - 9 ) : 0 ) ; b I == 27 ) exit ( 0 ) ; } } bl ( ) ; SDL_Flip ( U ) ; SDL_Delay ( 60 ) ; } } 
              int c , h , v , x , y , s , i , b ; int 
            main ( ) { initscr ( ) ; P ( cb , 
          rea , k ) ( ) ; 
        P ( n , oec , ho ) ( 
       ) ; for ( curs_set ( 0 ) ; s = x = COLS / 2 
      ; P ( flu , shi , np ) ( ) ) { timeout ( y = c = v = 0 ) ; 
      P ( c , lea , r ) ( ) ; for ( P ( 
      mva , d , dstr ) ( 2 , 3 + x , 
      G ) ; ; P ( usl , eep , ) ( U ) ) { 
       P ( m , vad , dstr ) ( y >> 8 , x , 
    "    " ) ; for ( i = LINES ; i -- > 0 
  ; mvinsch ( i , 0 , 0 > ( ~ c | i - h - H & h - i ) ? ' ' 
: ( i - h | h - i + H ) < 0 ? '|' : '=' ) ) ; 
if ( ( i = ( y += v = getch ( ) > 0 ? I : v + 
  A ) >> 8 ) >= LINES || mvinch ( i *= 0 < i , x ) != ' ' || ' ' 
  != mvinch ( i , 3 + x ) ) break ; mvaddstr ( y 
    >> 8 , x , 0 > v ? F : B ) ; i = -- s 
    / - W ; P ( m , vpr , intw ) ( 0 , 
     COLS - 9 , " %u/%u " , ( 0 < i ) * i , b = b < i ? i : 
      b ) ; refresh ( ) ; if ( ++ c == D ) { c 
                        -= W ; h = rand ( ) % ( LINES - H - 6 
                          ) + 2 ; } } flash ( ) ; } } 
    int I = 256 , l , c , o , O = 3 ; void e ( 
   int L ) { o = 0 ; for ( l = 8 ; L >> ++ l && 
  16 > l ; o += l 
  << l - 1 ) ; 
  o += l * L - ( l << l - 1 ) ; { ; } 
  if ( pread ( 3 , & L , 3 , O + o / 8 ) < 
  2 ) exit ( 0 ) ; L >>= 7 & o ; 
  L %= 1 << l ; L >> 8 ? 256 - L ? e ( 
  L - 1 ) , c || 
  ( e ( c = L ) , 
  c = 0 ) : ( O 
   += ( - I & 7 ) * l + o + l >> 3 , I = L ) : putchar ( 
    L ) ; } int main ( int l , char * * o ) { 
       for ( 
      open ( 1 [ o ] , 0 ) ; ; e ( I ++ 
       ) ) ; } 
   efine S ( M , L , N , R ) J ( M , P ) ( L , N , R ) 
   efine QL ( L , R ) QR ( L , R ) 
   efine P ( L , N , R ) L , N , R 
   efine LP ( L , N , R ) U L , D L , ( N , R ) 
   efine R ( L , R ) W ( Y ( J ( E , X ) ( K ( L , R ) ) ) ) 
   efine RP ( L , N , R ) ( L , N ) , H R , T R 
   efine HP ( L , N , R ) L , N , R 
   efine K ( L , R ) J ( F , V ) ( L , R ) J 
( Q , sym_ ( K , M ( L , B R ) ) ) ( L , R ) 
   efine Q ( L , R ) QR ( L , R ) 
   efine E ( X ) E3 ( X ) 
   efine break H , 
   efine E0 ( X ) X 
   efine I ( X , E ) K 
   efine EX ( X ) E3 ( X ) 
A R , A J ( G ( L , _ ) , B R ) , C R ) ) 
C ) ) ( C J ( G ( L , _ ) , B R ) , QS ( L , R ) ) 
   efine Z ( L , R ) J ( B L , Y ) 
   efine N ( L , R ) J ( G ( L , _ ) , B R ) 
   efine HY ( L ) ( A L , halting ) 
   efine T ( R , L ) G ( sym_ , R ) ( L , ( , ) ) 
   efine H ( R , L ) G ( sym_ , R ) ( R , _ ) 
   efine M ( L , R ) B J ( G ( L , _ ) , R ) 
   efine D ( L , R ) G ( sym_ , R ) ( R , _ ) 
   efine U ( L , R ) G ( sym_ , R ) ( L , ( , ) ) 
   efine F0 ( L , R ) F ( L , R ) 
   efine F1 ( L , R ) F0 ( L , R ) ~ 
   efine F2 ( L , R ) F1 ( L , R ) R < L [ B R ] > -> 
Z ( N ( L , R ) , R ) ( N ( L , R ) ) 
   efine FV ( L , R ) F ( L , R ) 
   efine QH ( L , R ) QS ( L , R ) 
int puts ( char * ) ; 
   efine W ( W ) O ( W ) 
int main ( ) { puts 
   efine O ( W ) 
( R ( A , tape ) ) ; } f defined __STDC_VERSION__ && ( __STDC_VERSION__ > ( ( 256L + 128L + 4L + 2L ) * 512L ) ) 
  ndif 
  f EOF + __STDC__ 
  rror goofy ! 
  ndif 
typedef int met ; 
typedef char pro ; 
typedef unsigned char ser ; 
typedef size_t thr ; 
typedef typ and ; 
typedef struct { 
 thr val ; 
 and * not ; 
} ala ; 
static const thr cys = sizeof ( and ) << ( 2 + __STDC__ ) , unk = sizeof ( pro ) ; 
static void phe ( const ala not ) ; 
static void gly ( ala * const not , const and his ) ; 
met main ( met val , const pro * const his [ ] ) ; 
static void phe ( const ala not ) 
{ 
 thr xor = not . val ; 
 do { 
  met lys = ( met ) ( cys - 4u ) ; 
  -- xor ; 
  while ( lys >= 0 ) { 
   const and tyr = ( and ) ( ( ( and ) ( not . not [ xor ] >> lys ) ) % ( and ) 16u ) ; 
   lys -= 4 * printf ( "%c" , ( met ) tyr + 32 + 16 + ( ( 8 + EOF ) * ( ( met ) tyr / ( 8 + 2 ) ) ) ) ; 
  } 
 } while ( xor ) ; 
} 
static void gly ( ala * const not , const and his ) 
{ 
 and * const gln = realloc ( ( void * ) not -> not , ( not -> val + unk ) * sizeof his ) ; 
 if ( gln == NULL ) { 
  free ( not -> not ) ; 
  exit ( puts ( "throw up" ) ) ; 
 } 
 not -> not = gln ; 
 not -> not [ not -> val ] = his ; 
 ++ not -> val ; 
} 
met main ( met val , const pro * const his [ ] ) 
{ 
 -- val ; 
 if ( val == - EOF ) { 
  const pro * tyr = his [ val ] ; 
  const thr trp = 0u ; 
  thr ile = trp ; 
  while ( * tyr ) { 
   tyr = & tyr [ - EOF ] ; 
   ++ ile ; 
  } 
  if ( ile != trp ) { 
   ala not ; 
   not . val = ( ile + ( ( cys >> 2 ) - unk ) ) / ( cys >> 2 ) ; 
   not . not = calloc ( not . val , sizeof ( and ) ) ; 
   if ( not . not != NULL ) { 
    thr leu = trp , lys = trp ; 
    while ( ile -- ) { 
     const ser asx = ( ser ) tyr [ EOF ] ; 
     const ser glx = ( ser ) ( ( asx > ( ser ) 64u ) ? ( ser ) ( ( ser ) asx + ( ser ) 8u + ( ser ) 1u ) : ( ser ) asx ) ; 
     tyr = & tyr [ EOF ] ; 
     not . not [ leu ] = ( and ) ( ( and ) not . not [ leu ] | ( and ) ( ( ( and ) glx % ( and ) 16u ) << ( and ) lys ) ) ; 
     lys += 4u ; 
     if ( lys == cys ) { 
      lys = trp ; 
      ++ leu ; 
     } 
    } 
    phe ( not ) ; 
    val += printf ( "\n" ) / ( ( __LINE__ * L_tmpnam ) + TMP_MAX ) ; 
    for ( ; ; ) { 
     const and gln = ( and ) 0u , glu = ( and ) 1u , arg = ( and ) ( glu << ( cys - unk ) ) ; 
     and tla = gln ; 
     thr xor ; 
     if ( * not . not > glu ) { 
      ++ tla ; 
     } else { 
      for ( xor = unk ; xor < not . val ; ++ xor ) { 
       if ( not . not [ xor ] != gln ) { 
        ++ tla ; 
        break ; 
       } 
      } 
     } 
     if ( tla == gln ) { 
      break ; 
     } 
     if ( * not . not & glu ) { 
      and sec = gln ; 
      ala asn ; 
      asn . val = not . val ; 
      asn . not = malloc ( asn . val * sizeof sec ) ; 
      if ( asn . not == NULL ) { 
       free ( not . not ) ; 
       exit ( puts ( "laugh" ) ) ; 
      } 
      for ( xor = trp ; xor < asn . val ; ++ xor ) { 
       asn . not [ xor ] = not . not [ xor ] ; 
      } 
      if ( not . not [ not . val - unk ] & arg ) { 
       gly ( & not , gln ) ; 
      } 
      for ( xor = trp ; xor < not . val ; ++ xor ) { 
       const and xle = ( ( not . not [ xor ] & arg ) == arg ) ? glu : gln ; 
       not . not [ xor ] = ( and ) ( ( and ) ( not . not [ xor ] << unk ) + ( and ) sec ) ; 
       sec = xle ; 
      } 
      sec = gln ; 
      while ( asn . val < not . val ) { 
       gly ( & asn , gln ) ; 
      } 
      for ( xor = trp ; xor < not . val ; ++ xor ) { 
       const and asp = ( and ) ~ gln ; 
       if ( sec ) { 
        const and pyl = ( not . not [ xor ] >= ( asp - asn . not [ xor ] ) ) ? glu : gln ; 
        ++ not . not [ xor ] ; 
        sec = pyl ; 
       } else { 
        sec = ( not . not [ xor ] > ( asp - asn . not [ xor ] ) ) ? glu : gln ; 
       } 
       not . not [ xor ] = ( and ) ( not . not [ xor ] + asn . not [ xor ] ) ; 
      } 
      if ( sec ) { 
       gly ( & not , glu ) ; 
      } 
      for ( xor = trp ; xor < not . val ; ++ xor ) { 
       ++ not . not [ xor ] ; 
       if ( not . not [ xor ] != gln ) { 
        break ; 
       } 
      } 
      if ( xor == not . val ) { 
       gly ( & not , glu ) ; 
      } 
      free ( asn . not ) ; 
     } else { 
      * not . not = ( and ) ( * not . not >> unk ) ; 
      for ( xor = unk ; xor < not . val ; ++ xor ) { 
       if ( not . not [ xor ] & glu ) { 
        not . not [ xor - unk ] = ( and ) ( not . not [ xor - unk ] | arg ) ; 
       } 
       not . not [ xor ] = ( and ) ( not . not [ xor ] >> unk ) ; 
      } 
     } 
     phe ( not ) ; 
     val -= ( printf ( " %d\n" , val ) > BUFSIZ ) ? FILENAME_MAX : EOF ; 
    } 
    free ( not . not ) ; 
   } 
  } 
 } 
 return fclose ( stdout ) ; 
} 0 } ; char * p = , P [ 9999 ] , * d = P , * e [ ] = { "('A`)" 
                                  , "(A`)" , "('A)" , "('A`)" } , b 
                               q ( * s = __TIME__ ; extern void w ( ) { G ( g , * o ) for ( ; g -- 
                          ; ) ; } extern void x ( ) { } extern void y ( ) { } static void z 
                       ( char * p ) { for ( ; ( * d = * p ++ ) != 0 ; d ++ ) * d -= 061 * ( 59 == * d || * d == 81 ) ; } int 
                         main ( ) { char N [ ] = "<;iQ=/*do<;dQ=ook8?boc;aQ=odr8>oc;_Q<ox8>oc" 
                     ";^Q<d|8=o;]Q<dj8<Pk8<c]'?;QQdi8?P'Q)d8<9`8?c;Qdh8=P']Q<`c8>PQ9_8" 
                   ">b;og8=''`Q<`b8?'QQ9_8?c;dPe8dQa8<P]Q<``8=;'f8>QQ`]8?ocQQ_8=''_Q`8aQ" 
                "CYOUQWIN!]Q=;of8BQQ)88bc]QA98P'Qo]8>oQQ_8CP;QQ98b`_8@P8(Q`]'^Q=`']QB)88" 
              "bQQ]`8J;QQ`88bc99bd(`8iQ@''QQo^8E'`8c;QQ'Q``8?QQ`'kQ<o]8B9PQQ`';_Q<`_8<cbQ" 
            "<o_Q<o_QBdo`QQ';`Q=9`]8=bobQ_o_Q<o]8=';bQC(88cQ`bcgQ>oP']8<;cQ>98)^Q?''oc`Q>" 
           "oc']Q]8<;cQ>`8bbQA``QQ''`Q?88P;dQ=`)nQ?*/;;" ; G ( Z , 60 * ( 60 * ( 10 * * s + s [ 1 ] ) + s [ 3 ] * 10 + s [ 4 ] ) + s [ 6 ] * 10 + s [ 7 ] - 1933008 
                ) G ( l , ( Z + 86400 - * o ) % 86400 ) G ( M , o [ 3 ] * 17 + o [ 4 ] * 11 ) G ( O , ( & x - & w ) - ( & y - & x ) ? 1 : 0 ) G ( 
               m , * o ) G ( n , m ) G ( i , 0 ) G ( j , O ) if ( M > 197 ) for ( p = N ; * p ; ) if ( * p > 92 ) { * N = p [ 1 ] ; N [ 1 ] 
            = 0 ; for ( O = * p ++ - 90 ; 0 < O -- ; z ( N ) ) ; p ++ ; } else { s = p ; for ( O = * p ++ - 59 ; O -- ; p ++ ) 
         p [ - 1 ] = * p ; p [ - 1 ] = 0 ; z ( s ) ; } else { if ( M == 0 ) { * o = Z ; l = 0 ; } if ( o [ O + 3 ] && o [ O + 1 ] + ( O ? 3 : 5 
      "*p=#b,P[9999],*d=P,*e[]=" "{\"%s\", \"" "%s" "\",\"%s\",\"%s\"},   b\nq(%s)\n" 
            , * o , o [ 01 ] , o [ 2 ] , o [ 3 ] , o [ 4 ] , e [ 3 ] , e [ 1 ] , e [ 2 ] , * e , p ) ; z ( "/*;; " ) ; for ( i = 0 ; i ++ < 18 
               ; z ( ";" ) ) for ( j = 0 ; j ++ < 11 ; n = ( n * 193 + 287 ) % 384 ) { m = ( 97 + ( 67 * m ) ) % 198 ; for 
             ( O = 0 ; O ++ < n % 03 ; z ( "Q" ) ) ; s = d ; for ( z ( e [ ( n / 3 ) & 3 ] ) ; m < M && s - d ; * s ++ 
           = 040 ) ; } if ( l < 60 ) { for ( z ( ";Time:Q" ) ; ( l ++ < 60 ) ; z ( "#" ) ) ; for 
          ( z ( ";Heca" "t" "eQII:" "Q" ) ; o [ 3 ] ++ <= 24 ; z ( "#" ) ) ; z 
         ( Z ? "" : "Q(j" "a" "m" "me" "d" ")" ) ; for ( z ( 
       ";GlockQ18" "C:" "Q" ) ; o [ 4 ] ++ < 
      25 ; z ( "#" ) ) ; z ( Z - 1 ? ";" : "Q(jam" 
     "med);" ) ; } else z ( ";" 
    ";Gam" "eQover." 
   ";;" ) ; for 
                                  ( O = 0 ; O < 77 ; O 
                                    ++ ) z ( "Q" ) ; z ( "*" "" 
                                       "/" ) ; } 
                                          puts ( P ) ; ; 
                                              return + 0 ; } ) 
char X [ ] = 
  " ETIANMSURWDKGOHVF:L:PJBXCYZQ::54:3:::2&:+::::16=/:::(:7:::8:90" 
  "::::::::::::?_::::\"::.::::@:::'::-::::::::;!:):::::,:::::" ; 
int j , w , h , f , u , d , g , e , n , i , l , a , r , p , c , m , o , t , s , Q = 32 , T [ 32 ] , W [ 32 ] , I = 13000 ; 
int main ( int v , char * * b ) { 
  for ( i = 0 ; v > 0 && v < 5 && ( v *= t = fread ( X , 1 , 1 , stdin ) ) ; ) 
  for ( v - 1 && 101 == * 1 [ b ] ? ++ g % 1500 ? u += ( g & 1 ^ 1 ) * ( * X < 0 ? - * X : * X ) : ( f = e , e = w , w = d , d = u , 
    m = ( 1 - h % 2 * 2 ) * ( d - f ) / ( d < f ? d | 1 : 1 | f ) > 5 ? T [ h % Q ] = o + l , l = W [ 
    h ++ % Q ] = o , o = 0 : m , o ++ , u = main ( 0 , b ) ) : ( c = strrchr ( X , ~ ( Q & * X & * X / 2 ) & * X ) - X , j = 255 ) ; 
    v == 1 && ( c * j || main ( * X - Q ? 8 : 24 , b ) ) ; j /= 2 ) c < j ? 0 : main ( 9 + ( c - j ) / ( j / 2 + 1 ) % 2 * 10 , b ) ; 
  for ( a = u = 0 ; i <= Q * Q && ! v ; j > 7 && j < 13 ? s = c * s + T [ i / Q ] / 2 , s /= ++ c : 0 ) 
    ! ( i ++ % Q ) ? a = c > a ? u = s , c : a , c = s = 0 : 0 , j = T [ i % Q ] , j = j ? T [ i / Q ] * 10 / j : 0 , j *= ( j < 5 ) * 2 + 1 ; 
  for ( r += ( h - r ) / Q * Q ; i < v / 4 * I ; putchar ( ( i / I < v % 4 ) * i % 2 * 85 << ( i % 176 / 88 ) ) , i ++ ) ; 
  for ( g *= ! ! v ; r + t != h + 1 && h > 5 && ! v ; r + t != h + 1 ? ( W [ r % Q ] > 2 * u || r == h ? p = n = n > 6 ? 0 : 
    putchar ( X [ p - 1 + ( 1 << n ) ] ) & 0 : 0 , W [ r ++ % Q ] > 6 * u ? putchar ( Q ) : 0 ) : 0 ) 
    * X = Q , p = r % 2 ? ++ n , 2 * p + ( W [ r ++ % Q ] > 2 * u ) : p ; 
  return 0 ; 
} typedef union w w ; union w { 
   f ( w x , ... ) { va_list argh ; w 
   y ; va_start ( argh , x ) ; y = * 
   ( va_arg ( argh , w * ) ) ; va_end 
   ( argh ) ; z ( t ) ; } w f ( w fw ) 
   { r ( ( w ) { . c = & _ f } , fw ) ; } 
   int _ ; void * p ; w ( * c ) ( w , ... 
    ( sizeof ( w ) << 1 ) ; k [ 0 ] = x 
    ; k [ 1 ] = y ; z ( ( w ) { . p = k } ) 
    w x , ... ) { z ( t ) ; } w f = { . p 
    = ( w [ 1 ] ) { { . c = & _ f } } } ; 
    ) ; } ; w a ( w f , w x ) { w * d = f 
     . p ; z ( ( * d -> c ) ( x , d + 1 ) 
             ) ; } 
      w a_ ( w f , w fw ) { r ( f , 
   fw ) ; } w _ ( w f ) { w * k = f . p , r = 
  a ( * k , k [ 1 ] ) ; free ( k ) ; z ( r ) ; } 
 L ( F , f , x , ( w ) { . _ = x . _ ? x . _ * a ( _ ( f ) , 
( w ) { . _ = x . _ - 1 } ) . _ : 1 } ) l ( F_ , f , F ( f ) 
) L ( W , ( f ) , x , a ( f , a_ ( x , x ) ) 
) l ( Y , f , a ( W ( f ) , W ( f ) ) 
 ) int main ( ) { printf ( "%." "f\n" , 
    a ( a ( Y , F_ ) , ( w ) { . _ = 10 } ) . _ 
        / 60. / 60 / 24 
             ) ; } float I , bu , k , i , F , u , U , K , O ; char o [ 5200 ] ; int 
            h = 0 , t = - 1 , m = 80 , n = 26 , d , g , p = 0 , q = 0 , v = 0 , y = 112 , x = 40 ; float 
           N ( float_ ) { g = 1 << 30 ; d = - ~ d * 1103515245 & -- g ; return d * _ 
          / g ; } voidw ( int_ ) { if ( t < 0 ) { for ( g = 0 ; g < 5200 ; o [ g ++ ] = 
          0 ) ; for ( ; g ; o [ g + 79 ] = 10 ) g -= 80 ; for ( t = 37 ; g < 62 ; o [ 80 + g ++ ] = 32 ) ; 
         } if ( m && o [ h * 80 + m - 1 ] == 10 ) { for ( g = 0 ; g < 79 ; o [ t * 80 + g ++ ] = 0 ) { } o [ t 
         ++ * 80 + g ] = 10 ; t %= 64 ; n += 2 ; I = N ( 70 ) + 5 ; if ( n > 30 && ( I - x ) * ( I - x ) + n * 
        n > 1600 && R ( ) ) { O = 0 ; F = ( x = 0x1 != sizeof ( ' ' ) ) ? k = 1 + N ( 2 ) , i = 12 - k + N ( 
        8 ) , N ( 4 ) : ( k = 17 + N ( 5 ) , i = 0 , r ( ) [ 0 ] ? O = .1 : 0 ) ; for ( u = U = - .05 ; u < 32 ; 
        U = k + i + i * .5 * sin ( ( u += .05 ) + F ) ) for ( K = 0 ; K < U ; K += .1 ) if ( ( bu = K * 
       sin ( u / 5 ) , g = I + cos ( u / 5 ) * K ) >= 0 && g < 79 ) o [ g + ( int ) ( t + 44 + 
       bu * ( .5 - ( bu > 0 ? 3 * O : O ) ) ) % 64 * 80 ] = 32 ; x *= 02 
      - 1 ; n = O + x ? n = I + ( x ? 0 : N ( k ) - k / 2 ) , g = ( t + 42 ) % 
      64 , m = - ~ g % 64 , x ? g = m = - ~ m % 64 : 0 , n > 5 ? o [ g * 80 + 
     n - 3 ] = o [ m * 80 + n - 3 ] = 0 : 0 , n < 75 ? o [ g * 80 + n 
     + 2 ] = o [ m * 80 + n + 2 ] = 0 : 0 : 0 ; x = I ; } h = - ~ h % 64 
    ; m = 0 ; } putchar ( ( g = o [ h * 80 + m ++ ] ) ? g : _ ) ; 
   if ( g ) { w ( _ ) ; } } void W ( const char * _ 
  ) { for ( ; * _ ; w ( * _ ++ ) ) ; } int main ( int a 
  , char * * _ ) { while ( a -- ) d += _ [ a ] - ( char * ) 0 ; W ( 
 "oid o(O _){putchar(_);}O" "\40main(){O" "" 
"*_[512],**p=_,**d,b,q;for(b=0;b" "++<512;p=_+q)_[q" 
"=(p-_+1)*9%512]=(O*)p;" ) ; for ( ; ( g = getchar ( ) ) - EOF ; p = 
q ) { q = p ; for ( v = 512 ; p - q - g && q - p - g ; v -- ) q = - ~ q * 9 % 512 
; W ( "o(" ) ; if ( p > q ) w ( y ) , w ( 45 ) ; w ( 40 ) ; w ( y ^= 20 
) ; w ( 075 ) ; for ( a = 0 ; a < v ; a ++ ) w ( 42 ) ; for ( W ( "(O**" 
 ) ; a -- ; w ( 42 ) ) { } w ( 41 ) ; w ( y ^ 024 ) ; w ( 41 ) ; if ( p <= q ) w ( 
   45 ) , w ( y ^ 20 ) ; W ( ");" ) ; } for ( a = 7 ; a - 6 ; W ( a < 6 ? "{;}" : "" 
      ) ) for ( a = 0 ; a < 6 && ! o [ h * 80 + m + a ] ; a ++ ) { } W ( "r" 
         "etu" "rn+0;}\n" ) ; return 
             0 ; } 