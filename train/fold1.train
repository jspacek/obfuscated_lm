I jmp_buf J ; 
I void P ; 
I char L ; 
I int Q ; 
I H C ; 
I long long V ; 
I H char O ; 
I H short Y ; 
I H long long Z ; 
           O S [ ] = "syntax_error!" 
      "M@K~|JOEF\\^~_NHI]" ; L * N , * K , * 
        B , * E , * T , * A , * x , D ; Q ( * k ) ( ) , v ; V z ( P ) , j , _ , * 
      o , b , f , u , s , c , a , t , e , d ; J l ; Q _k ( P ) { R * K ? * K ++ : 
    ~ - d ; } V r ( L a ) { R a && putchar ( a ) ; } L n ( ) { R * T = j = 
         k ( ) , ++ j ; } O G ( P ) { * o = d , longjmp ( l , b ) ; } Z g ( Y a ) { R a 
      >> s | ( a & ~ - e ) << s ; } C p ( L * T ) { W ( r ( * T ++ ) ) ; * -- T - c && r ( c ) ; } L m 
    ( P ) { W ( ! ( ( v = A [ * T ++ ] ) - f ) ) ; R v ; } P q ( L * * N ) { O * q ; b = ! b ; f = - ~ b ; 
   u = f | b ; s = b << u ; c = s | f ; a = s << f ; t = - ~ u ; e = a 
        << u ; D = v = u << t ; q = S + c - ~ t ; q [ ~ s ] = a ; 
       q -- [ f ] += a ; q -- [ c ] += a ; B = ( L * ) 
       N + ~ e * e ; x = B + e ; A = B + e / f ; 
     o = ( V * ) ( x + a ) ; A [ - 
     ~ s ] = f ; T = K = A - 
    a * f ; A [ * -- q ] = c + 
    c ; * q = ! c ; W 
   ( ++ j && * ++ q ) 
   A [ * q - a ] = j ; 
   W ( v < D + c ) 
   x [ v - D ] = 
   v , A [ v ++ 
   ] = j ; ++ j 
    , v = D = e / 
     t ; W ( ++ 
      v <= D + f * 
       u ) x [ v - D + ~ 
       - c ] = v | a , A [ 
  v ] = A [ v | a ] = j ; 
    W ( ( A [ v ] = A [ v | a 
      ] = j , ++ v < a * u + ~ t ) ) ; 
         for ( ; E = * ++ N ; T [ ~ d ] 
     = a ) W ( * T ++ = * E ++ ) ; k = 
       T 
      - K ? _k : 
   getchar ; } Z h 
        ( C a ) { R ( g ( a ) << s * 
       f ) + g ( a >> s * f ) ; } P _i ( L * T ) 
      { * o || p ( T ) ; } V _b ( V a ) { Z e = a 
     ; R A [ * T ++ ] != v + c ? G ( ) : ~ - v ? a << z ( ) : c - A 
    [ * T ++ ] + b ? -- T , a >> z ( ) : e >> z ( ) ; } 
   V _c ( L * l ) { T = B + a ; W ( j ) * T -- 
   = v + j % c , j /= c ; E = B + ( * B == 
   a + c + u ) ; W ( T < B + a ) * 
   E ++ = * ++ T ; T = E ; 
   l - B && ++ * -- E ; } 
    P M ( Z k ) { L * p , e 
     = a >> u ; m ( ) && G ( 
      ) ; p = T = B ; _ = j = k 
       ; v = u << t , * T = a ; j < d 
       && ( * T ++ += c + u , j = j == - j ? ++ p , -- j : - j ) ; ! j ? * T ++ = 
      v : _c ( p ) ; * T ++ = - ~ s ; * T ++ = v ; * T ++ = a * t - s ; p = T 
    ; E = T += s * f ; W ( k ) * T -- = x [ k & ~ - a / f ] , k >>= e ; W ( T 
   - e * f > p ) * T -- = v ; W ( T < E ) * p ++ = * ++ T ; * p = d ; } P U 
   ( L * E ) { V * N = o , f ; * E = f = d ; W ( ++ f < c * u - u ) * ++ N 
   && ( M ( * N ) , r ( f + a * u ) , r ( - ~ s ) , p ( B ) , * ( T = E ) = d ) 
   ; } V w ( P ) { L * S = N , * x = N ; E = T = B ; E += a 
   << f ; 
   W ( T 
   < E 
   && n ( ) ) * 
   T == a - ~ u 
   ? U ( T ) , T : * T == c ? E = S ? T = S : T : S ? T : * T == ( a | u ) ? S = T : * T == a * f - c / f ? E = T : ! x && A [ * T ] != f ? x = T ++ : 
   ++ T ; * T = d ; R j && ! x ? w ( ) : T - B ; } P _d ( V e ) { L T = c * f - f ; V o = j * e + v ; D = d ; A [ v ] == T ++ ? D 
   = u << t : e > c && A [ v ] == T ++ && ( v | a ) - a * - ~ f < ~ - s ? D = b + ( v & a ) + a * f - c : d ; D && ( j = o - D ) ; } V y ( P ) { 
   V a = z ( ) ; W ( m ( ) && v < c + f && ( v -= u << b ) >= d ) v ? v - b ? v - f ? v - u ? v -= t , a = _b ( a ) : ( a &= z ( ) ) : ( a %= z ( 
   ) ) : ( a /= z ( ) ) : ( a *= z ( ) ) ; R -- T , a ; } V _f ( P ) { V e = c ; j = d ; D = b ; * T == u << t && ( e -= f ) && ( * 
   ++ T | a ) >> f == a - f && ( e <<= b ) && T ++ ; W ( D && ( v = * T ++ ) ) _d ( e ) ; R -- T , j ; } V F ( P ) { V n = y ( ) ; 
   W ( m ( ) && v < u * f ) v < t ? n += ( v - f ) * y ( ) : v - b ^ t ? n ^= y ( ) : ( n |= y ( ) ) ; R -- T , n ; } V i ( Z n ) { R n >> 
   a / f ? 
   n >> a 
     ? h ( n ) << a | h ( n >> a 
       ) : h ( n ) : g ( n ) ; } Q main ( Q x 
      , L * * K ) { V * A ; q ( K ) ; W ( w ( ) ) * * 
    K - c * c - b || p ( B ) , _i ( ! setjmp ( l ) ? T = B 
  , M ( ( ( A = ( * o = m ( ) == c - ~ s && ( j = a | T [ - b ] ) && 
       s - m ( ) == ~ s ) ? & o [ j - a * u ] : ( T = B , & _ ) ) , * A = F ( ) ) 
      ) , B : ( L * ) S ) ; } V z ( P ) { V 
     s ; W ( m ( ) && v <= f * c 
     ) R v < t ? ( v - f ) * 
    z ( ) : ( v -= u << 
    f ) < f ? v ? -- v 
   ? G ( ) : i ( z ( 
   ) ) : ~ z ( ) : 
   ( v -= f ) < u 
   ? v ? s = F ( ) 
   , m ( ) == a >> 
    b ? s : G ( ) : 
    _ : ! ( v -= 
     t ) ? -- T , _f 
      ( ) : v - f ? o [ 
       ( T [ - b ] | a ) - 
       a * u ] : ! z ( ) ; 
  G ( ) ; } ( ze , si , of ) ( ( ( n , i , t ) [ ] ) { _ ( ) , __VA_ARGS__ } ) / ( ze , si , of ) ( ( n , i , t ) ) - __ ( ) ) 
 ( n , i , t ) ( * ___ ) ( ( n , i , t ) ) = ( tch , pu , ar ) ; ( ub , do , le ) _ < : : > _ _ < % 
         - 2 , 1 , - 1.3 , 1.3 
, _ ( ) , _ ( ) , _ ( ) , _ ( ) , _ ( ) , _ ( ) , __ ( ',' , ',' , ',' , ',' , ',' ) * _ _ ( ) , ( _ _ ( ) 
- __ ( '_' , '_' ) ) * _ _ ( ) , _ ( ) , _ ( ) , _ ( ) , __ ( '_' , '_' ) * __ ( '_' , '_' , '_' , '_' , '_' ) * 
__ ( '_' , '_' , '_' , '_' , '_' ) * __ ( '_' , '_' , '_' , '_' , '_' ) + __ ( '_' , '_' , '_' , '_' , '_' ) 
, __ ( '_' , '_' , '_' , '_' , '_' , '_' , '_' , '_' , ) , _ ( ) m ( i , a , u ) ( ( n , i , t ) _ ) < % _ ( f , i ) ( 
 _ _ ( = , = ) __ ( _ ) ) _ ( _ ( f , i ) ( _ [ _ _ ( ) ____ ( _ , _ ) ] > _ [ _ _ ( ) ] ) _ [ _ _ ( ) ____ ( _ , _ 
, _ , _ , _ , _ , _ ) ] _ _ __ ( _ ) ) _ ( f , i ) ( _ [ _ _ ( ) ____ ( _ , _ , _ ) ] > _ [ _ _ ( ) + __ ( ) ] || 
_ [ _ _ ( ) ____ ( _ , _ , _ , _ , _ , _ , _ ) ] _ ( = , = ) __ ( ) ) r ( e , t ) _ [ __ ( _ , _ , _ , _ , _ , _ ) ] _ _ _ 
[ __ ( _ , _ , _ , _ , _ , _ , _ ) ____ ( _ , _ , _ , _ , _ , _ ) ] / _ [ __ ( _ , _ , _ , _ , _ ) ____ ( _ , _ , _ , _ , _ , _ ) ] * ( _ [ 
  __ ( ) ] - _ [ _ ( ) ] ) + _ [ _ ( ) ] ; _ [ __ ( _ , _ , _ , _ , _ , _ , _ ) ] _ _ _ [ __ ( _ , _ , _ , _ , _ , _ , _ ) ____ 
( _ , _ , _ , _ , _ ) ] / _ [ _ _ ( ) ] * ( _ [ __ ( _ , _ , _ , ) ] - _ [ __ ( _ , _ , ) ] ) + _ [ __ ( _ , _ , ) ] ; _ [ __ ( _ , _ , _ , _ , _ 
, _ , _ , _ ) ] _ _ _ [ _ _ ( ) - __ ( ) ] _ _ _ [ __ ( _ , _ , _ , _ , _ ) + _ _ ( ) - __ ( ) ] _ _ _ ( ) ; 
_f : _ [ __ ( _ , _ , _ , _ ) ] _ _ _ [ __ ( _ , _ , _ , _ , _ , _ , _ , _ ) ] * _ [ __ ( _ , _ , _ , _ , _ , _ , _ , _ ) ] ; 
_ [ __ ( _ , _ , _ , _ , _ ) ] _ _ _ [ _ _ ( ) - __ ( ) ] * _ [ _ _ ( ) - __ ( ) ] ; _ [ __ ( _ , _ , _ , _ , _ , _ , _ , _ , _ 
) ] _ _ __ ( _ , _ ) * _ [ __ ( _ , _ , _ , _ , _ , _ , _ , _ ) ] * _ [ _ _ ( ) - __ ( ) ] + _ [ __ ( _ , _ , _ , _ , _ , _ , _ ) ] ; 
_ [ __ ( _ , _ , _ , _ , _ , _ , _ , _ ) ] _ _ _ [ __ ( _ , _ , _ , _ ) ] - _ [ __ ( _ , _ , _ , _ , _ ) ] + _ [ __ ( _ , _ , _ , _ , _ , 
_ ) ] ; _ ( _ [ _ _ ( ) ____ ( _ , _ , _ , _ , ) ] ++ ) _ ( f , i ) ( ( _ [ _ _ ( ) ____ ( _ , _ , _ , _ , ) ] < _ [ _ _ ( ) 
____ ( _ , _ , _ , _ , _ ) ] ) && ( _ [ __ ( _ , _ , _ , _ ) ] + _ [ __ ( _ , _ , _ , _ , _ ) ] < _ [ _ _ ( ) ____ ( _ , _ , _ , _ , _ , _ ) 
] ) ) _ ( to , go ) _f ; _ ( ar , ch ) ( m , i , au ) [ ] _ _ < % __ ( _ , _ , _ ) * _ _ ( ) ____ ( _ , _ ) , __ 
( _ , _ , _ , _ ) * _ _ ( ) ____ ( _ , _ , _ ) , __ ( _ , _ , _ , _ , _ , _ ) * _ _ ( ) ____ ( _ , _ , _ , _ ) , __ ( _ , _ , _ , _ ) 
* _ _ ( ) ____ ( _ , _ , _ , _ , _ ) , __ ( _ , _ , _ , _ ) * _ _ ( ) ____ ( _ , _ , _ , _ , _ , _ ) , __ ( _ , _ , _ , _ ) * _ _ 
( ) ____ ( _ , _ ) % > ; ___ ( ( m , i , au ) [ ( ( n , i , t ) ) _ [ _ _ ( ) ____ ( _ , _ , _ , _ ) ] % __ ( _ , _ , _ , _ , _ ) ] ) ; 
 _ ( _ [ __ ( _ , _ , _ , _ , _ , _ , _ ) + __ ( _ , _ , _ , _ , _ , _ ) ] ++ ) { m ( i , a , u ) ( _ ( ) ) ; _ ( _ [ _ _ ( ) 
____ ( _ , _ ) ] ++ ) _ ( _ [ _ _ ( ) ____ ( _ , _ , _ ) ] _ _ _ ( ) ) _ ( f , i ) ( _ [ __ ( _ , _ , _ , _ , _ , _ , _ ) + 
_ _ ( ) ] != __ ( _ ) ) ___ ( _ _ ( ) ) ; { m ( i , a , u ) ( __ ( ) ) ; r ( e , t ) % > char J [ 1 << 18 ] ; int G [ W * p ] , _ , k , I = W / 4 + 1 , w = p / 4 + 1 ; float C , B , e ; 
unsigned So long A , n , d , t , h , x , f , o , r , a , l , L , F , i , s , H = 1 << 18 , b = 250 , D [ 1 << 14 ] , z [ W * p ] , q 
= 0x820008202625a0 ; main ( ) { Display * j = XOpenDisplay ( 0 ) ; Window u = XCreateSimpleWindow 
( j , RootWindow ( j , 0 ) , 0 , 0 , W , p , 1 , 0 , 0 ) ; XImage * Y = XCreateImage ( j , DefaultVisual ( j , 0 ) , 24 
, 2 , 0 , ( char * ) G , W , p , 32 , 0 ) ; XEvent M ; for ( XMapWindow ( j , u ) ; XSelectInput ( j , u , 1 ) && a - 
65307 ; ) { if ( ! H ) { if ( XCheckWindowEvent ( j , u , 1 , & M ) ) { a = XLookupKeysym ( & M . xkey , 0 ) ; * ( 
a & 1 ? & C : & B ) -= ( .05 
- a / 2 % 2 * .1 ) * ! ( a - 
1 & 4092 ^ 3920 ) ; a + 
2 & 0xfe0 ^ 0xfc0 || ( 
s = a + 2 & 31 ) ; } else 
{ y ( k , p + ) { F = k % w * 4 | k / w ; float a [ 6 ] , S = ( F - p / 2. ) / p ; 
y ( _ , W + ) { i = _ % I * 4 | _ / I ; if ( F < p & i < W ) { o = 1 ; L = i + F * W ; if 
( l = i & 3 ) ; else { l = F & 3 ; o = W ; } h = z [ L - o * l ] ; f = z [ L + ( 4 - 
l ) * o ] ; t = F - p / 2 || i - W / 2 ; r = h ^ f ; if ( ! l | ! t | ( int ) r | ( ! 
( h - 3 & 3 ) && 258063 & r >> 38 ) ) { float V = ( i - W / 2. ) / p , U = O ( 
S , 1 , B ) , m = 32768 , Q = m ; a [ 4 ] = O ( - 1 , S , B ) ; a [ 3 ] = O ( U , V , C ) 
; a [ 5 ] = O ( - V , U , C ) ; P ( ( a + 3 ) , s * 42 ) ; t || ( A = d ) ; f = 0 ; y ( n 
, ) { float N = a [ n + 3 ] , E = 1024 / fabs ( N ) ; b = N < 0 ; float K = 
( ( ( q >> 20 * n ) ^ ~ - b ) + ! b & 1023 ) / 1024. ; y ( d , ) a [ d ] = a [ d + 3 ] 
* E ; a [ n ] = round ( a [ n ] ) ; P ( a , K ) ; i = q + d ; P ( a , 1 ) ; e = E * 
K ; for ( ; e < m ; i += d ) { l = X ( i ) ; t = r = l ^ ( l ^ l - ( 1 << 6 * n ) ) 
& 63 << 6 * n ; if ( b ) { r = l ; l = t ; } if ( J [ r ] ) l = r ; if ( t = J 
[ l ] ) { x = ( n - 1 ) ? ( i | i >> 40 ) & 1023 | i >> 8 & 4190208 | 4194304 
: i & 1023 | i >> 28 & 4190208 | ( b ^ l == r ) << 23 ; if ( h = D [ ( x >> 6 
& 0xf | x >> 14 & 0x3f0 ) + t * 768 ] ) { o = h ; f = n | l * 4 | x << 32 ; m 
= e ; } if ( t == 8 & e < Q ) Q = e ; } e += E ; } } b = ( 255 - ( ( f & 3 ) + 
2 ) % 3 * 51 ) * ( 1 - m / 32768 ) ; o = o * b >> 8 ; G [ L ] = o >> 32 << 8 | o & 
16711935 ; z [ L ] = 3 * ( Q <= m ) | f | b << 56 ; } else { d = l * ( f << 
8 >> 40 ) + ( 4 - l ) * ( h << 8 >> 40 ) >> 2 & 16774143 ; o = D [ ( d >> 6 & 
15 | d >> 14 & 1008 ) + J [ ( int ) h / 4 ] * 768 ] * ( b = h >> 56 ) >> 8 ; G [ 
L ] = o >> 32 << 8 | o & 16711935 ; z [ L ] = ( 
int ) h | d << 32 | b << 56 ; } } } } q += A ; 
XPutImage ( j , u + 0 , DefaultGC ( j , J [ X ( q 
) ] = 0 ) , Y , 0 , 0 , 0 , 0 , W , p ) ; } } else { L = 
-- H / 768 ; J [ H ] = R % 16 * ( R % 4 < abs ( ( H >> 
6 & 63 ) - 32 ) + abs ( ( H 
>> 12 & 63 ) - 32 ) - 3 ) ; 
i = H & 15 ; F = H % 768 
>> 4 ; if ( L < 16 ) { if 
( L - 1 | ! ( R % 3 ) ) b = R % 
96 ^ 255 ; l = i * i * 3 + i * 81 / 4 & 3 ; a = L > 3 ? L - 8 ? L - 5 ? 9858122 : 12365733 - 488848 * ( ( i + F / 4 * 4 ) % 8 && F % 
4 ) : R % 2 * 5298487 : 3352537 * L * L - 14202379 * L + 19205553 ; if ( L == 4 ) if ( F < l + 18 ) a = 6990400 ; else 
if ( l > F - 19 ) b *= 0.7 ; if ( L == 3 ) { if ( ( i - 1 & 15 ) < 14 & ( F - 1 & 15 ) < 14 & ! ( F & 16 ) ) { a = 12359778 ; _ = 7 
- i ; k = 7 - F % 16 ; _ ^= _ >> 31 ; k ^= k >> 31 ; b = 196 - R % 32 + ( k > _ ? k : _ ) % 3 * 42 ; } else { b *= 1 + R % 2 * ( .5 
- ( i & 1 ) ) ; } } D [ H ] = ( a & 16711935 | ( a & 65280 ) << 24 ) * ( b >> ( F >> 5 ) ) >> 8 & 0xff00ff00ff ; } } } } "|~0y'vWtA@:LcO9d}y.!uL!Gd+ml(<+Ds!J" 
            "e.6!r!%l6G!n~^<i=%pEwL%P!'<!FQt%u 5toG57j/3" 
         "!:E%;!ea!!!WqE0z!f/y}!%!!Qi6!uzt!n}?]!bl!ak!SetR<" 
       "Zj$x!~V!n&g8!cK! KrgR'8@c]!%-q9V.3fa[E8X%dY'w!#H <P~6" 
      "?guhljL!^P% ?" "8!@dP,!!o+fb" 
     "!pv!;!Hm%Ro4" "n:}nkD!Q!kN" 
     "e:| 'b5sc!e" 
     signal ( 13 , 1 ) , _ ( ) ; } f ( ) 
 char * O0 = O_o , OO , * Q1 , O5 [ 97 ] ; int * Q5 , _Q = 0 , Q0 = 0 , _O = 0 , _0 = 0 , O = 5 , QQ , O6 , Q6 , O3 
, Q4 , O4 = 41088 , O1 = sizeof ( O5 ) , O7 = 234 ; long long __ ; _ ( ) Q_ ( { ) int * Q3 , Q2 , O2 , C , 
QO , O9 = O , O8 = ! ! ! ! ! ! ! ! ! ! k ( RAFT ) ) ; long long Q8 ; char * Q9 = O_ ( 1 A ) O_ ( % dB ) O_ ( % dC 
) O_ ( 34 m ) "\xe2%c%c\r\n" O_ ( 0 m ) O_ ( % dA ) , * Q7 ; __ += ( __ * 92 + * O0 - 35 - __ ) * ( QO = Q_ ( ! 
! ) ( * O0 - 33 ) * ! O9 -- ) , O0 += O1 * QO , QO && _ ( ) , Q Q4 && ( O -- , _ ( ) , O0 += 194 , O ++ , Q4 -- , _ ( 
) ) ) , Q O = 0 , __ = 0 , _ ( ) , O = 3 , _ ( ) ) , Q __ && ( C = __ & 15 , _O += ( C < 2 ) * 12 + ! ( QO = C & 14 ^ 2 ) * ( 
4 - _O ) + ( C == 6 ) * ( 12 - 2 * _O ) + ( C > 6 ) * ( 9 - ( C - 7 ) % 3 ) , _Q += ! QO * ( _Q % QQ + ( C & 1 ) * O3 - _Q ) , 
_0 += ! _0 * ! QO + ( 1 - 2 * _0 ) * ! ( C ^ 4 ) , ( C == 5 ) && ( __ >>= 4 , Q8 = __ , Q7 = O0 , Q4 = __ & 15 , O = 1 , _ 
( ) | O ++ & _ ( ) , __ = Q8 , O0 = Q7 ) , Q3 = ( _Q += O8 * ( 9 * O4 * 
O1 > lrand48 ( ) ) + ( _O %= 8 , ( ( _O % 6 > 2 ) - ( _O % 
7 < 2 ) ) * QQ + ( ( _O + 7 ) % 8 < 3 ) - ( _O > 4 ) ) * ( C > 5 ) , 
Q2 = _Q / O3 ) * O6 + Q5 + ( O2 = _Q % QQ ) / 2 , * Q3 = * 
Q3 % O4 + O4 | ( 1 << Q_ ( "" "@CADBEHI" ) [ _Q % 2 + _Q 
% O3 / QQ * 2 ] - 64 ) * _0 , sprintf ( O5 , Q9 , Q2 + 1 , 
O2 / 2 , * Q3 >> 8 , 85 * 3 & * Q3 , Q2 + 1 ) && _0 && ( O = 8 , 
Q1 = O5 , _ ( ) ) , Q0 += ( O2 > Q0 ) * _0 * ( O2 - Q0 ) , __ 
+= ! ( C > 9 ) * ( 3 - __ + ( __ >> 4 ) ) - 3 , __ += ( C > 12 
) * ( ( __ << 4 ) + C - 3 - __ ) , usleep ( O4 * _0 / ( 3 * 
O8 + 1 ) ) , O = 3 , _ ( ) ) ) , ! O9 -- && read ( 
1 , & OO , 1 ) > 0 && ( O = ( QO = OO == 35 ) * 3 + 6 , _ ( ) 
, QO && ( OO = 10 , O = 6 , _ ( ) , 1 ) || ( O = 4 , _ ( ) ) , 0 ) || close ( dup2 ( 3 - dup2 ( 1 , dup ( 0 ) - 3 ) , 1 ) 
* 0 + 2 ) * 0 || Q write ( 1 , "> " , 2 ) , ioctl ( Q0 = 0 , TIOCGWINSZ , O5 ) ^ -- O & ( O3 = ( QQ = ( O6 = * 
( ( short * ) O5 + 1 ) ) * 2 ) * 4 ) , Q6 = - O1 , Q5 = calloc ( 3 * O6 , 8 ) , _ ( ) ) , Q ( O = 8 , QO = ! ( O2 = OO - 
10 ) | ! ( Q2 = OO - 32 ) * ( Q0 + 58 > QQ ) | ( Q0 + 12 > QQ ) ) && ( Q1 = O_ ( 3 B ) , _ ( ) , write ( 1 , "> " , 2 ) 
) , Q0 += ! QO * ! Q2 * 4 - QO * Q0 , O2 * Q2 && ( ! Q0 && ( memset ( Q5 , 0 , 3 * O3 ) , Q0 = 4 , Q1 = "\n\n\n" 
O_ ( 3 A ) , _ ( ) ) , O = 7 , _Q = 7 * QQ + Q0 + 2 , _O = _0 = 0 , OO += ( OO > 64 & OO < 91 ) * 32 , O0 = Q_ ( O_o ) + 
O7 , _ ( ) , ( * O0 - OO ) || ( O = 2 , O0 += 'a' , _ ( ) ) ) ) , Q * O0 - OO ) && ( * ( O0 += O1 ) - 33 ) && ( O = 0 , 
_ ( ) , O = 7 , O0 += O1 , _ ( ) ) , Q write ( 0 , Q1 , strlen ( Q1 ) ) ) , Q OO = Q_ ( O_o ) [ Q6 += O1 ] , ( Q6 
 % strlen ( O_o ) - O7 ) && ( O = 6 , _ ( ) , O = 9 , _ ( ) ) ) ; Q_ ( } ) 
main ( ) 
{ 
    puts ( "hello world!" ) ; 
} 
                char * s = 
                r 'Q]                    bh' l vQ ^ k g & c : % n | 
                N ] _o ptj9 lwg + ) d : b kg 
                c8 + ) d8 a % g + ) d8 _ g & ; bh 
                 g + u ) | d8ak = bl } ( Q ^ og ( O { MK6lM L ( rR pOpM866OsRlm N ( q 
                Q ] OsR _ ( lQoOa N9 m vOwwRor ~ } ( cN mkM : q ( Q ] % _ ( uU ] } _ { 8 b 
                % mRh ^ OaaD % / RI4 4 SNH % N4 RlMG / 2 MJ 24 O3NF ( tQ ? 1l N * N 
                + Q ] l mq9l8b ^ d , d xv SOPm R8 / lM ; b h & ^ / lM : k8b % & Q ^ - 
                h % c9 . / & N McPc % - d8 , c8 7 : b % ^ h % : 79 b ^ % 7 ON8r % Qr h Q 
                On % q N % O ~ M qN OMp RmPQ O % rQ rQ 
                MkQN 77 O j kd 7 O % d8 ( r RmM 
                : ( luN ] ( % mRMmO % lNRmO_loa8 % % O < b ( lQ h 'lQ    O^ln    ;b' % N & O ^ 6 sN 9 slltwzh & TmS 
                % R N oNS & pRM7O 
                                                mR8 } ( qQ O < b 
                                                '7M{N^kh        ' Q ] 
                    7 sN '    M8q;k' N_7vN 'nSM8    ' nR ; % M 
                    rQ ] 6 yN _ pQaM8m { px TmSt 6 O sM nRmUd s d77sNOsd 8 j 
                = nk ; | 8 k9 b1g ( Q ^ ) c : % ] k * Q ] g 9 % _h * ] + wnS _ + sTaa : & % { R 
                M < % { S { O_ & < kP8 ; '(    0d:`184>b)^15)OM        :23h)QN<' / M 
                    = b ( ^ 'h(Q]0h#    c_kah%0d9`b' / O ( Q ^ ( / SlM90 % M ( / RM ; & c & kckQ , - c 
                    . & kccMcOP & d 9 g ( = 6 : 69 j = b5g ( Q ^ 3 ( 2l NUO < b4 
                         7 O Q ] 0 ( 2 ( Q ] '2O    3' Q ] '_3a    N_1' 5 OMaMch & T mR RMPmSk U 7 
                        O 8 _a % % mS ] l_ % mR mS ] ] h 9 j_la _ 6 N ] g 9 j_laaaN : g 
                oM : 6 % N9b % g Q ^ 6 % N8b % g ^ l peoqemtemw Q7 O jQ O7 Q Ok 
                 7 OMQ ] k_ 7 O ckQaOrON epne luelue lpeoqempepneu e kf _a 
                                                lf ) ) * + , * * , * ) - ) / ) , 0 ) .0 ( 6 / 2 + 667 , ( & 
                . ] , * s , * c , d , t ; ; 
                ( * ++ s = Q [ d ++ ] ) ; ) ; for ( ; n > 1 && ( * ++ s = v [ 1 ] [ tgANs = H ; d = * c ++ 
                % 93 , d - 9 ; ) { in tYv = * s , g [ ] = { n + v , v - n , n * _ 
                , _ , , < v , n ? v / n : 0 , , , v >> n , v == n } ay 
                > t = 0 ; d < 4 && d >= 2 * ! ! n && ( c -= d / 3 * 2 _KK3 + * c ++ , t || v != 98 + d ) ; ) t += v ++ / 6 - 16 
                ? 0 : v / 2 % 3 - 1 cq * d - 1 4 ; t > 0 _t < 3 _z ( 105 < * c_X 
                [ d - 7 7 ] : d > 55 ? H_1 ) 21 ] = n , * _ _8 ( 9 ? * ++ s_4 & 12 > d_C f3 ] += 21 - d * 2 
                : d < 3 4 ? t : _Zadat57 < d ? p utchar ( n ) , v : 6 < a ] ( g + 99 ] = a { d2 xa6 , n 
                ; } re turnY_ . 
                p = q = 5000 + 0 + d ; * s ; s ++ ) if ( * s > 32 ) * p ++ = * s - 89 ? * s : 32 ; for ( p = 
                1152 + q ; ( b = * p ++ ) ; ) { for ( d [ 17 ] = 10 ; x = * p ++ , b < 
                92 && 34 < b -- ; * r ++ = x ) if ( x == 9 * 9 ) for ( ; * q ; x = 34 
                ) * r ++ = * q ++ ; for ( p -= b < 92 ; b -- > 4 * 23 ; r ++ ) * r = r [ 36 - x ] ; } puts ( d ) ; 
                return ( 0 ) ; } 
typedef 
    volatile 
     double 
T ; T 
H = 4.503599627370496e15 , 
a = 2.271681097355226e15 , 
n = 4.294967296e9 , 
d = 4.023233417e9 , 
l = 3.135045272e9 , 
e = 1.159922023e9 , 
w = 8.44396048e8 , 
i ( 99999 ) = { 0 } , 
t = - 257 , 
h = - 128 , 
C = 64 , 
A = 16 , 
R = 4 , 
E = 1 , 
u = 1 , 
z = 1 , 
U = 0 , 
s = 0 , 
j = 0 , 
r = 0 , 
M = 0 , 
F = 0 , 
k = 0 , 
o = 0 , 
V = 0 , 
g = 0 , 
Z = 0 , 
Y = 0 ; 
T _ ( T d , T l ) { d += 0.5 ; d /= l ; d += 1.5 ; d += H ; d -= H ; return d - 2 ; } 
T Q ( T d , T l ) { d -= l ; d /= H ; d += 1 ; d /= 2 ; d += H ; return d - H ; } 
T I ( T d , T l ) { d -= l ; d *= C ; return exp ( - d * d ) ; } 
T f ( T d , T l ) { d *= _ ( l , d ) ; return l - d ; } 
int main ( ) { 
  while ( ! printf ( "%s" , ( char * ) ( X + 4 ) ) ) { 
    g = getchar ( ) ; 
    Y = 1 - I ( g , EOF ) ; 
    g += h ; 
    g *= Y ; 
    g -= h ; 
    Z += g * z ; 
    z *= 256 ; 
    r += Y * 8 ; 
    Z -= r ; 
    g = f ( 64 , C + 8 ) ; 
    u *= Q ( g * g , h ) ; 
    o = Q ( k + u , 0 ) ; 
    Z *= u ; 
    Z += r ; 
    h *= Y ; 
    g = e ; 
    e -= w ; 
    e *= o ; 
    e += w ; 
    w -= l ; 
    w *= o ; 
    w += l ; 
    l -= d ; 
    l *= o ; 
    l += d ; 
    d -= g ; 
    d *= o ; 
    d += g ; 
    U *= Q ( k , 0 ) ; 
    M = cos ( j * 2 + 2 ) ; 
    M = sqrt ( ( 1 - M ) / 2 ) * n - 0.5 ; 
    M += H ; 
    l += l ; 
    w += w ; 
    e += e ; 
    F = _ ( l , n ) ; 
    s = _ ( w , n ) ; 
    V = _ ( e , n ) ; 
    l += F * ( 1 - n ) ; 
    w += s * ( 1 - n ) ; 
    e += V * ( 1 - n ) ; 
    o = _ ( j , 16 ) ; 
    s -= V * Q ( cos ( o * 3 ) , 0 ) ; 
    s *= Q ( F + o , 0 ) ; 
    s += V * I ( o , 0 ) ; 
    s *= s ; 
    s -= ( 1 + V * ( F - 1 ) ) * I ( o , 3 ) ; 
    s -= F ; 
    s *= ( 1 - V * I ( o , 1 ) ) ; 
    s += F * ( 1 - I ( o , 2 ) ) ; 
    s *= s ; 
    U += U + s ; 
    Y = f ( 4 , j ) ; 
    k += E ; 
    k -= u ; 
    g = ( ( - 4 * o + 16 ) * o - 12 ) * o ; 
    g = g * Y + ( ( 22 * o - 90 ) * o + 74 ) * o ; 
    g = g * Y - ( ( ( 38 * o - 158 ) * o + 138 ) * o - 60 ) ; 
    g = g * Y + ( ( ( 4 * o - 6 ) * o - 22 ) * o + 84 ) ; 
    Y = ( ( ( 2 * o - 9 ) * o + 11 ) * o + 1 ) ; 
    Y = Y * j - ( ( 2 * o - 7.5 ) * o + 4.5 ) * o ; 
    o = I ( k , 32 ) ; 
    M -= H ; 
    M *= o ; 
    Y = f ( 16 , Y ) ; 
    Y = i ( A + Y ) ; 
    Y += U ; 
    Y *= o ; 
    d += Y ; 
    d += M ; 
    d = f ( n , d ) ; 
    g *= o ; 
    g = pow ( 2 , ( g / 12 ) ) ; 
    d *= g ; 
    g = ( d + 0.5 * g ) / n + 1.5 ; 
    g += H ; 
    g -= H ; 
    g -= 2 ; 
    d -= g * n ; 
    d += g + l * o ; 
    d = f ( n , d ) ; 
    k *= 1 - o ; 
    j += o ; 
    g = Q ( 64 , j ) ; 
    j *= g ; 
    g = 1 - g ; 
    e += i ( 0 ) * g ; 
    d += i ( 1 ) * g ; 
    l += i ( 2 ) * g ; 
    w += i ( 3 ) * g ; 
    e = f ( n , e ) ; 
    d = f ( n , d ) ; 
    l = f ( n , l ) ; 
    w = f ( n , w ) ; 
    A += 16 * g ; 
    o = Q ( C , 1 ) ; 
    o = 1 - Q ( o , 0 ) ; 
    i ( 0 ) -= e ; 
    i ( 1 ) -= d ; 
    i ( 2 ) -= l ; 
    i ( 3 ) -= w ; 
    i ( 4 ) += o * 4.6727004911171048e-153 ; 
    i ( 5 ) += o * 1.6937441874215991e190 ; 
    g = exp ( - E * ( g + u ) * C * C ) ; 
    i ( 0 ) *= g ; 
    i ( 1 ) *= g ; 
    i ( 2 ) *= g ; 
    i ( 3 ) *= g ; 
    i ( 4 ) *= g ; 
    i ( 5 ) *= g ; 
    o = exp ( - o * C * C ) ; 
    o *= Q ( C , 3.9999e5 ) ; 
    i ( 0 ) += e ; 
    i ( 1 ) += d ; 
    i ( 2 ) += l ; 
    i ( 3 ) += w ; 
    i ( 4 ) += o * 4.522871578970112e217 ; 
    i ( 5 ) += o * 7.90055321525613e115 ; 
    E *= Q ( C / 4 + 1 , A ) ; 
    o = Q ( j + E , 0 ) ; 
    g = pow ( 2 , t - 304 - n * o ) ; 
    i ( R + 4 ) = ( H + H / 85 + a ) * g ; 
    i ( C / 4 ) = Z ; 
    C += u ; 
    R += o - 1 ; 
    Y = Q ( z * E , n - 1 ) ; 
    Z *= 1 - Y ; 
    z += Y * ( 1 - n ) - 1 ; 
    z *= o ; 
    a *= o ; 
    t *= o ; 
    o = _ ( j , 2 ) ; 
    o = 1 - j + o * 4 ; 
    o = _ ( i ( R ) , pow ( 16 , o ) ) ; 
    g = _ ( o , 16 ) ; 
    o -= g * 16 ; 
    o += Q ( o , 9 ) * 39 ; 
    g = _ ( o , 16 ) ; 
    g *= I ( j , 6 ) ; 
    o -= g * 16 ; 
    t += g ; 
    z += 1 ; 
    a += o * z * Q ( 7 , j ) ; 
    t += o * 16 * Q ( j , 6 ) ; 
    j += 1 - E ; 
    j *= Q ( C * E + 8 , j ) ; 
  } 
  return 0 ; 
} typedef struct e { 
 int op ; int x ; int y ; long a ; long b ; struct e * n ; 
} E ; 
typedef struct { 
 int y ; 
 E * e ; 
} X ; 
typedef struct { 
 long q ; 
 unsigned long long y ; 
} h ; 
typedef struct { 
 unsigned long z ; 
 unsigned long j ; 
 h b [ 1 ] ; 
} H ; 
int I ; 
int P ; 
H * A , * B ; 
FILE * f , * g ; 
X * Q , * q ; 
H * 
N ( H * O ) 
{ 
 unsigned long z ; 
 H * Y ; 
 z = O ? O -> z << 1 : 65536 ; 
 if ( ! ( Y = realloc ( O , sizeof ( * O ) + z * sizeof ( O -> b ) ) ) ) 
  err ( 2 , 0 ) ; 
 Y -> z = z ; 
 if ( ! O ) 
  Y -> j = 0 ; 
 return Y ; 
} 
H * 
F ( FILE * Q ) 
{ 
 unsigned long long h ; 
 H * y ; 
 long L , o , n ; 
 unsigned char buf [ 65536 ] , * b ; 
 y = N ( 0 ) ; 
 L = 1 ; 
 o = 0 ; 
 h = 14695981039346656037ULL ; 
 y -> b [ L ] . q = o ; 
 while ( 0 < ( n = fread ( buf , 1 , sizeof ( buf ) , Q ) ) ) { 
  b = buf ; 
  while ( 0 < n -- ) { 
   h ^= * b ; 
   h += ( h << 1 ) + ( h << 4 ) + ( h << 5 ) + ( h << 7 ) + ( h << 8 ) + ( h << 40 ) ; 
   o ++ ; 
   if ( * b ++ == '\n' ) { 
    y -> b [ L ++ ] . y = h ; 
    if ( y -> z <= L ) 
     y = N ( y ) ; 
    y -> b [ L ] . q = o ; 
    h = 14695981039346656037ULL ; 
   } 
  } 
 } 
 y -> j = L - 1 ; 
 rewind ( Q ) ; 
 return y ; 
} 
FILE * 
O ( char * u ) 
{ 
 int i ; 
 FILE * Q ; 
 if ( ! ( Q = fopen ( u , "r" ) ) && ! strcmp ( "-" , u ) ) { 
  if ( ( Q = tmpfile ( ) ) ) { 
   while ( ( i = getchar ( ) ) != EOF ) 
    fputc ( i , Q ) ; 
   rewind ( Q ) ; 
  } 
 } 
 if ( ! Q ) err ( 2 , "%s" , u ) ; 
 return Q ; 
} 
void 
W ( FILE * Q ) 
{ 
 int i ; 
 while ( ( i = fgetc ( Q ) ) != EOF ) { 
  putchar ( i ) ; 
  if ( i == '\n' ) 
   break ; 
 } 
} 
E * 
R ( E * K ) 
{ 
 E * a , * b ; 
 b = 0 ; 
 while ( K ) { 
  a = K -> n ; 
  K -> n = b ; 
  b = K ; 
  K = a ; 
 } 
 return b ; 
} 
void 
D ( E * K ) 
{ 
 E * a , * b ; 
 for ( K = R ( K ) ; K ; ) { 
  b = K ; 
  if ( K -> op ) { 
   do { 
    a = b ; 
    b = b -> n ; 
   } while ( b && b -> op && a -> y + 1 == b -> y ) ; 
   if ( K -> y < a -> y ) 
    printf ( "%da%d,%d\n" , K -> x , K -> y , a -> y ) ; 
   else 
    printf ( "%da%d\n" , K -> x , K -> y ) ; 
   fseek ( g , K -> b , SEEK_SET ) ; 
   for ( ; K != b ; K = K -> n ) { 
    printf ( "> " ) ; 
    W ( g ) ; 
   } 
  } else { 
   do { 
    a = b ; 
    b = b -> n ; 
   } while ( b && ! b -> op && a -> x + 1 == b -> x ) ; 
   if ( K -> x < a -> x ) 
    printf ( "%d,%dd%d\n" , K -> x , a -> x , K -> y ) ; 
   else 
    printf ( "%dd%d\n" , K -> x , K -> y ) ; 
   fseek ( f , K -> a , SEEK_SET ) ; 
   for ( ; K != b ; K = K -> n ) { 
    printf ( "< " ) ; 
    W ( f ) ; 
   } 
  } 
 } 
} 
void 
K ( int k ) 
{ 
 X h = Q [ k - 1 ] ; 
 X v = Q [ k + 1 ] ; 
 int x , y , op ; 
 E * p ; 
 if ( v . y < h . y + 1 ) { 
  op = 1 ; 
  y = h . y + 1 ; 
  p = h . e ; 
 } else { 
  op = 0 ; 
  y = v . y ; 
  p = v . e ; 
 } 
 x = y - k ; 
 if ( 0 < y || 0 < x ) { 
  E * e = malloc ( sizeof ( * e ) ) ; 
  e -> x = x ; 
  e -> y = y ; 
  e -> n = p ; 
  e -> op = op ^ I ; 
  e -> a = A -> b [ x ] . q ; 
  e -> b = B -> b [ y ] . q ; 
  if ( I ) { 
   long c = e -> a ; 
   e -> a = e -> b ; 
   e -> b = c ; 
   e -> x = y ; 
   e -> y = x ; 
  } 
  Q [ k ] . e = e ; 
 } 
 while ( x < A -> j && y < B -> j && A -> b [ x + 1 ] . y == B -> b [ y + 1 ] . y ) { 
  x ++ ; 
  y ++ ; 
 } 
 Q [ k ] . y = y ; 
} 
int 
T ( void ) 
{ 
 int k , p , d ; 
 if ( A -> j > B -> j ) { 
  void * t = A ; 
  A = B ; 
  B = t ; 
  I = 1 ; 
 } 
 d = B -> j - A -> j ; 
 if ( ! ( q = calloc ( A -> j + B -> j + 3 , sizeof ( * Q ) ) ) ) 
  err ( 2 , 0 ) ; 
 for ( k = 0 ; k < A -> j + B -> j + 3 ; k ++ ) 
  q [ k ] . y = - 1 ; 
 Q = q + A -> j + 1 ; 
 p = - 1 ; 
 do { 
  p ++ ; 
  for ( k = - p ; k < d ; k ++ ) { 
   K ( k ) ; 
  } 
  for ( k = d + p ; d <= k ; k -- ) { 
   K ( k ) ; 
  } 
 } while ( Q [ d ] . y != B -> j ) ; 
 if ( ! P ) 
  D ( Q [ d ] . e ) ; 
 free ( q ) ; 
 return d + 2 * p ; 
} 
int 
main ( int x , char * * y ) 
{ 
 int i ; 
 while ( ( i = getopt ( x , y , "d" ) ) != - 1 ) { 
  switch ( i ) { 
  case 'd' : 
   P = 1 ; 
   break ; 
  default : 
   optind = x ; 
   break ; 
  } 
 } 
 if ( x <= optind ) 
  errx ( 2 , "usage: %s [-d] file1 file2" , * y ) ; 
 f = O ( y [ optind ] ) ; 
 g = O ( y [ optind + 1 ] ) ; 
 if ( ! ( A = F ( f ) ) ) 
  err ( 2 , "%s" , y [ optind ] ) ; 
 if ( ! ( B = F ( g ) ) ) 
  err ( 2 , "%s" , y [ optind + 1 ] ) ; 
 i = T ( ) ; 
 if ( P ) printf ( "%d\n" , i ) ; 
 return 0 < i ; 
} e , h , f , g , i , j , k , l , m , n , o , p = 1 , * q , r , s = 5 , t , * u , x , y , z , A , B , C [ 
    333 * 7 ] , d = 333 ; D , E , F , G [ 2 ] , H , I , J , K , L , M , N = 1 , O , P , Q 
    , * R ; char * S , * * T ; ; 
    SDL_Surface * U , * V ; int * W ( X 
    ) { u = C + X * 7 ; b * u ) { u ++ ; x = u [ 0 ] ; y = u [ 1 
    ] ; H = u [ 2 ] ; z = ( H % 8 ) * 
    i ; A = ( H / 8 ) * i ; B = u [ 3 
    ] ; return u ; ; } return 
    0 ; } Y ( ) { O = 50 ; r = 0 ; t = 1 ; 
    } Z ( X , m , n , o ) { ; 
    return W ( X ) && B && ( m < x + i && n < 
    y + i && x < m + i && y < n + o ) ; } int * ba ( int * u ) { int X 
    , * bb = C ; a ( X , bb += 7 ) { b ! * bb ) { * bb = 1 ; R 
    = bb + 1 ; H = 6 ; while ( H -- ) * R ++ = * u ++ ; return bb ; } } return 0 ; } bc ( e ) { q [ 2 ] = e ; } bd 
    ( be , bf ) { int X , bg ; m += be ; n += bf ; I = e 
    - i ; m = m < 0 ? 0 : ( m > I ? I : m ) ; a ( X , 0 ) { b Z ( X 
    , m , n , o ) ) { bg = B & 1 ; b D && bg ) continue ; 
    m -= be ; n -= bf ; b B & 8 ) { u [ - 1 ] = 0 ; j = 1 ; bc ( 8 ) ; b B & 32 ) { n -= i ; 
    o = i * 2 ; } } b B & 16 && ! O ) { bc ( 32 + ( o > i ? 8 : 0 ) ) ; Y ( ) ; u [ - 1 ] = 0 ; } 
    b ( B & 128 && bf && s < 0 ) || ( B & 64 ) ) u [ - 1 ] = 0 ; b bg && ! O ) { b bf && s > 0 ) { 
 u [ 2 ] -- ; u [ 3 ] = bf = 0 ; s = - 6 ; } else { b j ) { bc ( 0 ) ; b o > i ) n += o = i ; D = 30 ; j = 0 ; 
 } else { bc ( 24 ) ; Y ( ) ; L = - 1 ; } } } b B & 4 ) { b bf && s < 0 ) { int I [ ] = { x , y - i , u [ 
 5 ] , u [ 4 ] , rand ( ) % 2 ? 1 : - 1 , 2 } ; u [ 2 ] ++ ; u [ 3 ] = 2 ; ba ( I ) ; } } b bf ) s = 1 ; break ; } 
 } } bh ( m , e , k , bi ) { H = k / 2 ; G [ bi ] = m > e - H ? k 
 - e : ( m > H ? H - m : 0 ) ; } bj ( X , be , bf ) { int bk ; 
 u [ 0 ] += be ; u [ 1 ] += bf ; W ( X ) ; E = x , F = y , I = 0 ; a 
 ( bk , 0 ) { b I = ( X != bk && Z ( bk , E , F , i ) && ( B & 6 ) 
 ) ) break ; } W ( X ) ; b I ) { b bf ) u [ 1 ] -= bf ; b 
 be ) { u [ 0 ] -= be ; u [ 4 ] *= - 1 * be ; } } W ( X ) ; } 
 bl ( ) { int bm = n , X ; SDL_FillRect ( U , 0 , M ) ; X = 4 ; while ( X 
 -- ) bd ( r , 0 ) ; X = 3 ; while ( X -- ) bd ( 0 , s ) ; b n > h && ! O ) Y ( ) ; 
 t = bm == n ; q [ 0 ] = m ; q [ 1 ] = n ; bh ( m , e , k , 0 ) ; bh ( n , h , l , 1 ) ; 
 a ( X , 0 ) { b W ( X ) ) { b B & 9 ) { bj ( X , u [ 4 ] , 0 ) ; bj ( X , 0 , 2 ) ; } b B & 1 ) { * u += u [ 4 ] ; b 
    ++ u [ 5 ] > 20 ) { u [ 4 ] *= - 1 ; u [ 5 ] = 0 ; } z += K 
    % 2 ? i : 0 ; } J = i ; b q == u ) { J = o ; b ! O ) { b 
    r ) z += i * ( K % 2 ) ; b ! t ) z = 48 ; z += p < 0 ? i * 4 : 0 
    ; } } b q != u || ! ( D && 0 == D % 3 ) ) { SDL_Rect 
    bn = { z , A , i , J } , bo = { G [ 0 ] + x , G [ 1 ] + y , i , 
    J } ; SDL_BlitSurface ( V , & bn , U , & bo ) ; } } 
    } b ( s += 2 ) > 2 ) s = 2 ; K ++ ; D -= D ? 1 : 0 ; b O ) 
    b ! -- O ) exit ( L ) ; } bp ( X ) { return strtol 
 ( T [ X ] , 0 , 0 ) ; } bq ( int H , int * br , int bs ) { int bt ; 
 bt = Q - P ; b bt > bs ) bt = bs ; SDL_MixAudio ( br , S + P , bt , 
 128 ) ; P += bt ; b P >= Q ) P = 0 ; } SDL_AudioSpec bu = { 8000 
 , 8 , 1 , 0 , 256 , 0 , 0 , bq } , bv ; main ( int bw , char * * bx ) { T 
  = bx ; int by , H = 255 , bz = H << 8 , bA = bz << 8 , bB = bA << 8 , 
  bC = bp ( 5 ) , bD = bp ( 6 ) ; SDL_Event bE ; o = i = bC / 8 ; k = bp ( 1 ) 
  , l = bp ( 2 ) , e = bp ( 3 ) , h = bp ( 4 ) ; M = bp ( 9 ) ; SDL_Init ( 
  0xffff ) ; b ! * ( char * ) & N ) { H = bB ; bz = bA ; bA = bz >> 8 ; 
  bB = 255 ; } U = SDL_SetVideoMode ( k , l , 0 , 0 ) ; V = SDL_CreateRGBSurface ( 1 << 15 , bC , bD , 32 , H , bz 
  , bA , bB ) ; fread ( V -> pixels , bC * bD * 4 , 1 , fopen ( T [ 7 ] , "r" ) ) ; SDL_OpenAudio ( & 
  bu , 0 ) ; SDL_LoadWAV ( T [ 8 ] , & bv , & S , & Q ) ; SDL_PauseAudio ( 0 ) ; 
  for ( ; ; ) { int u [ 6 ] , * I ; H = 0 ; while ( H < 6 ) scanf ( 
     "%d " , u + H ++ ) ; b u [ 5 ] < 0 ) break ; I = ba ( 
     u ) ; b ! u [ 3 ] ) { q = I + 1 ; m = u [ 0 ] ; n = u [ 1 ] ; 
    } } for ( ; ; ) { while ( 
  SDL_PollEvent ( & bE ) ) { by = bE . type == 3 ; b ! O && ( by || bE . 
  type == 2 ) ) { I = bE . key . keysym . sym ; b I == 276 ) r = 
  by ? 0 : ( p = - 1 ) ; b I == 275 ) r = by ? 0 : ( p = 1 ) ; b I == 32 ) by ? 
  0 : ( t ? ( s = - 9 ) : 0 ) ; b I == 27 ) exit ( 0 ) ; } } bl ( ) ; SDL_Flip ( U ) ; SDL_Delay ( 60 ) ; } } 
              int c , h , v , x , y , s , i , b ; int 
            main ( ) { initscr ( ) ; P ( cb , 
          rea , k ) ( ) ; 
        P ( n , oec , ho ) ( 
       ) ; for ( curs_set ( 0 ) ; s = x = COLS / 2 
      ; P ( flu , shi , np ) ( ) ) { timeout ( y = c = v = 0 ) ; 
      P ( c , lea , r ) ( ) ; for ( P ( 
      mva , d , dstr ) ( 2 , 3 + x , 
      G ) ; ; P ( usl , eep , ) ( U ) ) { 
       P ( m , vad , dstr ) ( y >> 8 , x , 
    "    " ) ; for ( i = LINES ; i -- > 0 
  ; mvinsch ( i , 0 , 0 > ( ~ c | i - h - H & h - i ) ? ' ' 
: ( i - h | h - i + H ) < 0 ? '|' : '=' ) ) ; 
if ( ( i = ( y += v = getch ( ) > 0 ? I : v + 
  A ) >> 8 ) >= LINES || mvinch ( i *= 0 < i , x ) != ' ' || ' ' 
  != mvinch ( i , 3 + x ) ) break ; mvaddstr ( y 
    >> 8 , x , 0 > v ? F : B ) ; i = -- s 
    / - W ; P ( m , vpr , intw ) ( 0 , 
     COLS - 9 , " %u/%u " , ( 0 < i ) * i , b = b < i ? i : 
      b ) ; refresh ( ) ; if ( ++ c == D ) { c 
                        -= W ; h = rand ( ) % ( LINES - H - 6 
                          ) + 2 ; } } flash ( ) ; } } 
    int I = 256 , l , c , o , O = 3 ; void e ( 
   int L ) { o = 0 ; for ( l = 8 ; L >> ++ l && 
  16 > l ; o += l 
  << l - 1 ) ; 
  o += l * L - ( l << l - 1 ) ; { ; } 
  if ( pread ( 3 , & L , 3 , O + o / 8 ) < 
  2 ) exit ( 0 ) ; L >>= 7 & o ; 
  L %= 1 << l ; L >> 8 ? 256 - L ? e ( 
  L - 1 ) , c || 
  ( e ( c = L ) , 
  c = 0 ) : ( O 
   += ( - I & 7 ) * l + o + l >> 3 , I = L ) : putchar ( 
    L ) ; } int main ( int l , char * * o ) { 
       for ( 
      open ( 1 [ o ] , 0 ) ; ; e ( I ++ 
       ) ) ; } 
typedef struct T * _ ; struct T { int t , i ; char * a ; _ * b , c , d , e , f ; } m , x , y ; struct stat z ; int u ; void * H ; 
int K ( int c ) { return strchr ( " \n\t" , c ) ; } void B ( _ s , _ p ) { s Y = realloc ( s Y , S s W * sizeof ( _ ) ) ; s Y [ s 
W - 1 ] = p ; } _ C ( char * d , int l ) { _ s = A ; s X = d ? d : P 1 ) ; s W = l < 0 ? d ? strlen ( d ) : 0 : l ; return s ; } _ E ( _ s ) { _ r 
= A ; int i = 0 ; U ; i < s W ; ) { U ; i < s W R K ( s X [ i ] ) ; ) i S ; int j = i ; U ; j < s W R ! K ( s X [ j ] ) ; ) j S ; V j - i ) B ( 
r , C ( s X + i , j - i ) ) ; i = S j ; } return r ; } int F ( _ a , _ b ) { return a W == b W R ! memcmp ( a X , b X , a W ) ; } void 
I ( _ s , char c ) { char * d = P 1 ) ; * d = c ; B ( s , C ( d , 1 ) ) ; } void 
 J ( char * d , int l , int o , _ v ) { _ n = C ( d , l ) ; _ w ; U l = 0 ; l 
< D d W ; ) { w = D d Y [ l S ] ; V F ( w Z , n ) ) { V o > w W ) return ; goto O ; } } 
B ( D d , w = A ) ; w Z = n ; O : w W = o ; w L d = v ; } int M ( _ b , int p , char * t , int 
g ) { _ f = A ; f L e = A ; f X = t ; int h = g , i = 0 , j = 0 , n = b 
 W ; char c = 0 , d , * o = b X ; U ; p < n ; ) { t = j ? "" : f X ; 
 int k = p ; _ r = H ; U ; p < n ; ) { int l = 0 ; U ; p < n R o [ p ] == 92 ; ) { l S ; p S ; } c = o 
[ p S ] ; V c ^ 10 || ! l % 2 || ! g ) { d = c == 35 R ! i R ! g || c == 10 R g ^ 2 ; V d || strchr ( t , c 
) ) { r = C ( o + k , p - k - d * l / 2 - 1 ) ; V d R l % 2 ) { r X [ r W - 1 ] = c ^ 35 ? 32 : 
c ; c = 0 ; } break ; } } c = 0 ; } V ! j ) B ( f L e , r ? r : C ( o + k , n - k ) ) ; r 
= A ; switch ( c ) { case 35 : j S ; case 0 : break ; case 10 : goto O ; case 36 : switch ( d = o [ p S ] ) { case 36 : I ( f L e , 
d ) ; break ; default : I ( r Z = A , d ) ; goto o ; case 40 : case 123 : r L f = f ; r L e = A ; r X = d ^ 40 ? "}$" : ")$" ; f = r ; } 
break ; default : V f L f ) { r Z = f L e ; f = f L f ; o : r L t S ; B ( f L e , r ) ; } else goto O ; } i = f L f R g == 1 ; 
g = i ? 0 : h ; } O : x . c = f L e ; x . t = c ; return p ; } _ N ( _ s ) { _ o = C ( H , 0 ) ; U int i = 0 ; i < s W ; ) { _ p = s Y [ i S ] ; 
V p L t ) { _ n = N ( p Z ) ; p = C ( H , 0 ) ; U int j = 0 ; j < D d W ; ) { _ w = D d Y [ j S ] ; V F ( w Z , n ) ) { M ( w L d , 0 , "$" , 2 ) 
; p = N ( x . c ) ; break ; } } } o X = realloc ( o X , o W += p W ) ; memcpy ( o X + o W - p W , p X , p W ) ; } return o ; } _ O ( _ 
t ) { U int i = 0 ; i < D e W ; ) { _ s = D e Y [ i S ] ; V F ( s Z , t ) ) return s ; } _ s = A ; s Z = t ; s L d = A ; s L t -- ; B ( D 
e , s ) ; return s ; } void Q ( _ s ) { _ d = s Z ; V ! stat ( memcpy ( calloc ( 1 , d W + 1 ) , d X , d W ) , & z ) ) s L t = z . st_mtime ; 
V ! s W S ) { u = ! s L d W R s L t < 0 ; int i = 0 , j , k = s L t < 0 ; _ c = H , t ; U ; ! u R i < s L d W ; ) { _ a = s L d Y [ i S ] 
; U j = 0 ; ! u R j < a L d W ; ) { Q ( t = O ( a L d Y [ j S ] ) ) ; k |= t L t < 0 || t L t > s L t ; } V a Z W ) { c = a Z ; V a L 
d W ) J ( "<" , 1 , 0 , * a L d Y ) ; } } U j = 0 ; ! u R c R k R j < c W ; ) { J ( "@" , 1 , 0 , d ) ; s = N ( c Y [ j S ] ) ; U ; s W R 
strchr ( "@+-" , * s X ) ; ) s X S ; u = system ( s X ) ; } } } void G ( _ b ) { U ; b W R K ( * b X ) ; ) { b X S ; b W -- ; } } 
int main ( int i , char * * a , char * * e ) { D d = A ; D e = A ; D c = A ; char p [ ] = "NBLF\1Nblfgjmf\1" , * q = p ; U ; ( * q ++ ) -- ; 
) ; J ( p , 4 , 0 , C ( * a S , - 1 ) ) ; U i = 0 ; i < 3 ; i += 2 ) { U ; * a ; ) { q = * a ; U ; * q R * q ^ 61 ; ) q S ; V * q ) J ( * a , q - * a , i + 1 , C ( q 
+ 1 , - 1 ) ) ; else V ! i ) B ( D c , C ( * a , - 1 ) ) ; a S ; } a = e ; } stat ( p + 5 , & z ) ; i = z . st_size ; _ b = C ( H , 0 ) , c , d ; b W = read 
( open ( p + 5 , 0 ) , b X = P i ) , i ) ; U ; u < i ; ) { V b X [ u ] ^ 9 ) { U ; u < i R K ( b X [ u ] ) ; ) u S ; u = M ( b , u , "=:$" , 0 ) ; y = x ; 
switch ( x . t ) { case 58 : u = M ( b , u , "$" , 0 ) ; D f = c = A ; c L d = E ( N ( x . c ) ) ; c Z = A ; d = E ( N ( y . c ) ) ; U ; d W -- ; ) B ( O ( * d 
Y S ) L d , c ) ; break ; case 61 : u = M ( b , u , "" , 0 ) ; G ( c = N ( x . c ) ) ; G ( d = N ( y . c ) ) ; U ; d W -- R K ( d X [ d W ] ) ; ) ; J ( d X 
, S d W , 2 , c ) ; } } else { u = M ( b , S u , "$" , 1 ) ; I ( x . c , 0 ) ; B ( D f Z , x . c ) ; } } V ! D c W R D e W ) B ( D c , D e Y [ 0 ] 
Z ) ; U u = 0 ; ! u R D c W -- ; ) Q ( O ( * D c Y S ) ) ; return u ; } 
   efine S ( M , L , N , R ) J ( M , P ) ( L , N , R ) 
   efine QL ( L , R ) QR ( L , R ) 
   efine P ( L , N , R ) L , N , R 
   efine LP ( L , N , R ) U L , D L , ( N , R ) 
   efine R ( L , R ) W ( Y ( J ( E , X ) ( K ( L , R ) ) ) ) 
   efine RP ( L , N , R ) ( L , N ) , H R , T R 
   efine HP ( L , N , R ) L , N , R 
   efine K ( L , R ) J ( F , V ) ( L , R ) J 
( Q , sym_ ( K , M ( L , B R ) ) ) ( L , R ) 
   efine Q ( L , R ) QR ( L , R ) 
   efine E ( X ) E3 ( X ) 
   efine break H , 
   efine E0 ( X ) X 
   efine I ( X , E ) K 
   efine EX ( X ) E3 ( X ) 
A R , A J ( G ( L , _ ) , B R ) , C R ) ) 
C ) ) ( C J ( G ( L , _ ) , B R ) , QS ( L , R ) ) 
   efine Z ( L , R ) J ( B L , Y ) 
   efine N ( L , R ) J ( G ( L , _ ) , B R ) 
   efine HY ( L ) ( A L , halting ) 
   efine T ( R , L ) G ( sym_ , R ) ( L , ( , ) ) 
   efine H ( R , L ) G ( sym_ , R ) ( R , _ ) 
   efine M ( L , R ) B J ( G ( L , _ ) , R ) 
   efine D ( L , R ) G ( sym_ , R ) ( R , _ ) 
   efine U ( L , R ) G ( sym_ , R ) ( L , ( , ) ) 
   efine F0 ( L , R ) F ( L , R ) 
   efine F1 ( L , R ) F0 ( L , R ) ~ 
   efine F2 ( L , R ) F1 ( L , R ) R < L [ B R ] > -> 
Z ( N ( L , R ) , R ) ( N ( L , R ) ) 
   efine FV ( L , R ) F ( L , R ) 
   efine QH ( L , R ) QS ( L , R ) 
int puts ( char * ) ; 
   efine W ( W ) O ( W ) 
int main ( ) { puts 
   efine O ( W ) 
( R ( A , tape ) ) ; } f defined __STDC_VERSION__ && ( __STDC_VERSION__ > ( ( 256L + 128L + 4L + 2L ) * 512L ) ) 
  ndif 
  f EOF + __STDC__ 
  rror goofy ! 
  ndif 
typedef int met ; 
typedef char pro ; 
typedef unsigned char ser ; 
typedef size_t thr ; 
typedef typ and ; 
typedef struct { 
 thr val ; 
 and * not ; 
} ala ; 
static const thr cys = sizeof ( and ) << ( 2 + __STDC__ ) , unk = sizeof ( pro ) ; 
static void phe ( const ala not ) ; 
static void gly ( ala * const not , const and his ) ; 
met main ( met val , const pro * const his [ ] ) ; 
static void phe ( const ala not ) 
{ 
 thr xor = not . val ; 
 do { 
  met lys = ( met ) ( cys - 4u ) ; 
  -- xor ; 
  while ( lys >= 0 ) { 
   const and tyr = ( and ) ( ( ( and ) ( not . not [ xor ] >> lys ) ) % ( and ) 16u ) ; 
   lys -= 4 * printf ( "%c" , ( met ) tyr + 32 + 16 + ( ( 8 + EOF ) * ( ( met ) tyr / ( 8 + 2 ) ) ) ) ; 
  } 
 } while ( xor ) ; 
} 
static void gly ( ala * const not , const and his ) 
{ 
 and * const gln = realloc ( ( void * ) not -> not , ( not -> val + unk ) * sizeof his ) ; 
 if ( gln == NULL ) { 
  free ( not -> not ) ; 
  exit ( puts ( "throw up" ) ) ; 
 } 
 not -> not = gln ; 
 not -> not [ not -> val ] = his ; 
 ++ not -> val ; 
} 
met main ( met val , const pro * const his [ ] ) 
{ 
 -- val ; 
 if ( val == - EOF ) { 
  const pro * tyr = his [ val ] ; 
  const thr trp = 0u ; 
  thr ile = trp ; 
  while ( * tyr ) { 
   tyr = & tyr [ - EOF ] ; 
   ++ ile ; 
  } 
  if ( ile != trp ) { 
   ala not ; 
   not . val = ( ile + ( ( cys >> 2 ) - unk ) ) / ( cys >> 2 ) ; 
   not . not = calloc ( not . val , sizeof ( and ) ) ; 
   if ( not . not != NULL ) { 
    thr leu = trp , lys = trp ; 
    while ( ile -- ) { 
     const ser asx = ( ser ) tyr [ EOF ] ; 
     const ser glx = ( ser ) ( ( asx > ( ser ) 64u ) ? ( ser ) ( ( ser ) asx + ( ser ) 8u + ( ser ) 1u ) : ( ser ) asx ) ; 
     tyr = & tyr [ EOF ] ; 
     not . not [ leu ] = ( and ) ( ( and ) not . not [ leu ] | ( and ) ( ( ( and ) glx % ( and ) 16u ) << ( and ) lys ) ) ; 
     lys += 4u ; 
     if ( lys == cys ) { 
      lys = trp ; 
      ++ leu ; 
     } 
    } 
    phe ( not ) ; 
    val += printf ( "\n" ) / ( ( __LINE__ * L_tmpnam ) + TMP_MAX ) ; 
    for ( ; ; ) { 
     const and gln = ( and ) 0u , glu = ( and ) 1u , arg = ( and ) ( glu << ( cys - unk ) ) ; 
     and tla = gln ; 
     thr xor ; 
     if ( * not . not > glu ) { 
      ++ tla ; 
     } else { 
      for ( xor = unk ; xor < not . val ; ++ xor ) { 
       if ( not . not [ xor ] != gln ) { 
        ++ tla ; 
        break ; 
       } 
      } 
     } 
     if ( tla == gln ) { 
      break ; 
     } 
     if ( * not . not & glu ) { 
      and sec = gln ; 
      ala asn ; 
      asn . val = not . val ; 
      asn . not = malloc ( asn . val * sizeof sec ) ; 
      if ( asn . not == NULL ) { 
       free ( not . not ) ; 
       exit ( puts ( "laugh" ) ) ; 
      } 
      for ( xor = trp ; xor < asn . val ; ++ xor ) { 
       asn . not [ xor ] = not . not [ xor ] ; 
      } 
      if ( not . not [ not . val - unk ] & arg ) { 
       gly ( & not , gln ) ; 
      } 
      for ( xor = trp ; xor < not . val ; ++ xor ) { 
       const and xle = ( ( not . not [ xor ] & arg ) == arg ) ? glu : gln ; 
       not . not [ xor ] = ( and ) ( ( and ) ( not . not [ xor ] << unk ) + ( and ) sec ) ; 
       sec = xle ; 
      } 
      sec = gln ; 
      while ( asn . val < not . val ) { 
       gly ( & asn , gln ) ; 
      } 
      for ( xor = trp ; xor < not . val ; ++ xor ) { 
       const and asp = ( and ) ~ gln ; 
       if ( sec ) { 
        const and pyl = ( not . not [ xor ] >= ( asp - asn . not [ xor ] ) ) ? glu : gln ; 
        ++ not . not [ xor ] ; 
        sec = pyl ; 
       } else { 
        sec = ( not . not [ xor ] > ( asp - asn . not [ xor ] ) ) ? glu : gln ; 
       } 
       not . not [ xor ] = ( and ) ( not . not [ xor ] + asn . not [ xor ] ) ; 
      } 
      if ( sec ) { 
       gly ( & not , glu ) ; 
      } 
      for ( xor = trp ; xor < not . val ; ++ xor ) { 
       ++ not . not [ xor ] ; 
       if ( not . not [ xor ] != gln ) { 
        break ; 
       } 
      } 
      if ( xor == not . val ) { 
       gly ( & not , glu ) ; 
      } 
      free ( asn . not ) ; 
     } else { 
      * not . not = ( and ) ( * not . not >> unk ) ; 
      for ( xor = unk ; xor < not . val ; ++ xor ) { 
       if ( not . not [ xor ] & glu ) { 
        not . not [ xor - unk ] = ( and ) ( not . not [ xor - unk ] | arg ) ; 
       } 
       not . not [ xor ] = ( and ) ( not . not [ xor ] >> unk ) ; 
      } 
     } 
     phe ( not ) ; 
     val -= ( printf ( " %d\n" , val ) > BUFSIZ ) ? FILENAME_MAX : EOF ; 
    } 
    free ( not . not ) ; 
   } 
  } 
 } 
 return fclose ( stdout ) ; 
} 0 } ; char * p = , P [ 9999 ] , * d = P , * e [ ] = { "('A`)" 
                                  , "(A`)" , "('A)" , "('A`)" } , b 
                               q ( * s = __TIME__ ; extern void w ( ) { G ( g , * o ) for ( ; g -- 
                          ; ) ; } extern void x ( ) { } extern void y ( ) { } static void z 
                       ( char * p ) { for ( ; ( * d = * p ++ ) != 0 ; d ++ ) * d -= 061 * ( 59 == * d || * d == 81 ) ; } int 
                         main ( ) { char N [ ] = "<;iQ=/*do<;dQ=ook8?boc;aQ=odr8>oc;_Q<ox8>oc" 
                     ";^Q<d|8=o;]Q<dj8<Pk8<c]'?;QQdi8?P'Q)d8<9`8?c;Qdh8=P']Q<`c8>PQ9_8" 
                   ">b;og8=''`Q<`b8?'QQ9_8?c;dPe8dQa8<P]Q<``8=;'f8>QQ`]8?ocQQ_8=''_Q`8aQ" 
                "CYOUQWIN!]Q=;of8BQQ)88bc]QA98P'Qo]8>oQQ_8CP;QQ98b`_8@P8(Q`]'^Q=`']QB)88" 
              "bQQ]`8J;QQ`88bc99bd(`8iQ@''QQo^8E'`8c;QQ'Q``8?QQ`'kQ<o]8B9PQQ`';_Q<`_8<cbQ" 
            "<o_Q<o_QBdo`QQ';`Q=9`]8=bobQ_o_Q<o]8=';bQC(88cQ`bcgQ>oP']8<;cQ>98)^Q?''oc`Q>" 
           "oc']Q]8<;cQ>`8bbQA``QQ''`Q?88P;dQ=`)nQ?*/;;" ; G ( Z , 60 * ( 60 * ( 10 * * s + s [ 1 ] ) + s [ 3 ] * 10 + s [ 4 ] ) + s [ 6 ] * 10 + s [ 7 ] - 1933008 
                ) G ( l , ( Z + 86400 - * o ) % 86400 ) G ( M , o [ 3 ] * 17 + o [ 4 ] * 11 ) G ( O , ( & x - & w ) - ( & y - & x ) ? 1 : 0 ) G ( 
               m , * o ) G ( n , m ) G ( i , 0 ) G ( j , O ) if ( M > 197 ) for ( p = N ; * p ; ) if ( * p > 92 ) { * N = p [ 1 ] ; N [ 1 ] 
            = 0 ; for ( O = * p ++ - 90 ; 0 < O -- ; z ( N ) ) ; p ++ ; } else { s = p ; for ( O = * p ++ - 59 ; O -- ; p ++ ) 
         p [ - 1 ] = * p ; p [ - 1 ] = 0 ; z ( s ) ; } else { if ( M == 0 ) { * o = Z ; l = 0 ; } if ( o [ O + 3 ] && o [ O + 1 ] + ( O ? 3 : 5 
      "*p=#b,P[9999],*d=P,*e[]=" "{\"%s\", \"" "%s" "\",\"%s\",\"%s\"},   b\nq(%s)\n" 
            , * o , o [ 01 ] , o [ 2 ] , o [ 3 ] , o [ 4 ] , e [ 3 ] , e [ 1 ] , e [ 2 ] , * e , p ) ; z ( "/*;; " ) ; for ( i = 0 ; i ++ < 18 
               ; z ( ";" ) ) for ( j = 0 ; j ++ < 11 ; n = ( n * 193 + 287 ) % 384 ) { m = ( 97 + ( 67 * m ) ) % 198 ; for 
             ( O = 0 ; O ++ < n % 03 ; z ( "Q" ) ) ; s = d ; for ( z ( e [ ( n / 3 ) & 3 ] ) ; m < M && s - d ; * s ++ 
           = 040 ) ; } if ( l < 60 ) { for ( z ( ";Time:Q" ) ; ( l ++ < 60 ) ; z ( "#" ) ) ; for 
          ( z ( ";Heca" "t" "eQII:" "Q" ) ; o [ 3 ] ++ <= 24 ; z ( "#" ) ) ; z 
         ( Z ? "" : "Q(j" "a" "m" "me" "d" ")" ) ; for ( z ( 
       ";GlockQ18" "C:" "Q" ) ; o [ 4 ] ++ < 
      25 ; z ( "#" ) ) ; z ( Z - 1 ? ";" : "Q(jam" 
     "med);" ) ; } else z ( ";" 
    ";Gam" "eQover." 
   ";;" ) ; for 
                                  ( O = 0 ; O < 77 ; O 
                                    ++ ) z ( "Q" ) ; z ( "*" "" 
                                       "/" ) ; } 
                                          puts ( P ) ; ; 
                                              return + 0 ; } ) typedef union w w ; union w { 
   f ( w x , ... ) { va_list argh ; w 
   y ; va_start ( argh , x ) ; y = * 
   ( va_arg ( argh , w * ) ) ; va_end 
   ( argh ) ; z ( t ) ; } w f ( w fw ) 
   { r ( ( w ) { . c = & _ f } , fw ) ; } 
   int _ ; void * p ; w ( * c ) ( w , ... 
    ( sizeof ( w ) << 1 ) ; k [ 0 ] = x 
    ; k [ 1 ] = y ; z ( ( w ) { . p = k } ) 
    w x , ... ) { z ( t ) ; } w f = { . p 
    = ( w [ 1 ] ) { { . c = & _ f } } } ; 
    ) ; } ; w a ( w f , w x ) { w * d = f 
     . p ; z ( ( * d -> c ) ( x , d + 1 ) 
             ) ; } 
      w a_ ( w f , w fw ) { r ( f , 
   fw ) ; } w _ ( w f ) { w * k = f . p , r = 
  a ( * k , k [ 1 ] ) ; free ( k ) ; z ( r ) ; } 
 L ( F , f , x , ( w ) { . _ = x . _ ? x . _ * a ( _ ( f ) , 
( w ) { . _ = x . _ - 1 } ) . _ : 1 } ) l ( F_ , f , F ( f ) 
) L ( W , ( f ) , x , a ( f , a_ ( x , x ) ) 
) l ( Y , f , a ( W ( f ) , W ( f ) ) 
 ) int main ( ) { printf ( "%." "f\n" , 
    a ( a ( Y , F_ ) , ( w ) { . _ = 10 } ) . _ 
        / 60. / 60 / 24 
             ) ; } float I , bu , k , i , F , u , U , K , O ; char o [ 5200 ] ; int 
            h = 0 , t = - 1 , m = 80 , n = 26 , d , g , p = 0 , q = 0 , v = 0 , y = 112 , x = 40 ; float 
           N ( float_ ) { g = 1 << 30 ; d = - ~ d * 1103515245 & -- g ; return d * _ 
          / g ; } voidw ( int_ ) { if ( t < 0 ) { for ( g = 0 ; g < 5200 ; o [ g ++ ] = 
          0 ) ; for ( ; g ; o [ g + 79 ] = 10 ) g -= 80 ; for ( t = 37 ; g < 62 ; o [ 80 + g ++ ] = 32 ) ; 
         } if ( m && o [ h * 80 + m - 1 ] == 10 ) { for ( g = 0 ; g < 79 ; o [ t * 80 + g ++ ] = 0 ) { } o [ t 
         ++ * 80 + g ] = 10 ; t %= 64 ; n += 2 ; I = N ( 70 ) + 5 ; if ( n > 30 && ( I - x ) * ( I - x ) + n * 
        n > 1600 && R ( ) ) { O = 0 ; F = ( x = 0x1 != sizeof ( ' ' ) ) ? k = 1 + N ( 2 ) , i = 12 - k + N ( 
        8 ) , N ( 4 ) : ( k = 17 + N ( 5 ) , i = 0 , r ( ) [ 0 ] ? O = .1 : 0 ) ; for ( u = U = - .05 ; u < 32 ; 
        U = k + i + i * .5 * sin ( ( u += .05 ) + F ) ) for ( K = 0 ; K < U ; K += .1 ) if ( ( bu = K * 
       sin ( u / 5 ) , g = I + cos ( u / 5 ) * K ) >= 0 && g < 79 ) o [ g + ( int ) ( t + 44 + 
       bu * ( .5 - ( bu > 0 ? 3 * O : O ) ) ) % 64 * 80 ] = 32 ; x *= 02 
      - 1 ; n = O + x ? n = I + ( x ? 0 : N ( k ) - k / 2 ) , g = ( t + 42 ) % 
      64 , m = - ~ g % 64 , x ? g = m = - ~ m % 64 : 0 , n > 5 ? o [ g * 80 + 
     n - 3 ] = o [ m * 80 + n - 3 ] = 0 : 0 , n < 75 ? o [ g * 80 + n 
     + 2 ] = o [ m * 80 + n + 2 ] = 0 : 0 : 0 ; x = I ; } h = - ~ h % 64 
    ; m = 0 ; } putchar ( ( g = o [ h * 80 + m ++ ] ) ? g : _ ) ; 
   if ( g ) { w ( _ ) ; } } void W ( const char * _ 
  ) { for ( ; * _ ; w ( * _ ++ ) ) ; } int main ( int a 
  , char * * _ ) { while ( a -- ) d += _ [ a ] - ( char * ) 0 ; W ( 
 "oid o(O _){putchar(_);}O" "\40main(){O" "" 
"*_[512],**p=_,**d,b,q;for(b=0;b" "++<512;p=_+q)_[q" 
"=(p-_+1)*9%512]=(O*)p;" ) ; for ( ; ( g = getchar ( ) ) - EOF ; p = 
q ) { q = p ; for ( v = 512 ; p - q - g && q - p - g ; v -- ) q = - ~ q * 9 % 512 
; W ( "o(" ) ; if ( p > q ) w ( y ) , w ( 45 ) ; w ( 40 ) ; w ( y ^= 20 
) ; w ( 075 ) ; for ( a = 0 ; a < v ; a ++ ) w ( 42 ) ; for ( W ( "(O**" 
 ) ; a -- ; w ( 42 ) ) { } w ( 41 ) ; w ( y ^ 024 ) ; w ( 41 ) ; if ( p <= q ) w ( 
   45 ) , w ( y ^ 20 ) ; W ( ");" ) ; } for ( a = 7 ; a - 6 ; W ( a < 6 ? "{;}" : "" 
      ) ) for ( a = 0 ; a < 6 && ! o [ h * 80 + m + a ] ; a ++ ) { } W ( "r" 
         "etu" "rn+0;}\n" ) ; return 
             0 ; } 